(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// app.js\r\n\r\nmodule.exports = function () {\r\n\tif (!Memory.sources) {\r\n\t\tMemory.sources = {};\r\n\t}\r\n\r\n\tif (!Memory.counts) {\r\n\t\tMemory.counts = {};\r\n\t}\r\n\r\n\tconst Move = __webpack_require__(/*! ./modules/move.js */ \"./src/modules/move.js\");\r\n\tthis.move = new Move();\r\n\r\n\tconst CreepRequisitioner = __webpack_require__(/*! ./modules/creepRequisitioner.js */ \"./src/modules/creepRequisitioner.js\");\r\n\tthis.creepRequisitioner = new CreepRequisitioner();\r\n\r\n\tconst Resource = __webpack_require__(/*! ./modules/resource.js */ \"./src/modules/resource.js\");\r\n\tthis.resource = new Resource();\r\n\r\n\t// run function will activate every loop\r\n\tthis.run = () => {\r\n\t\tthis.runRooms();\r\n\r\n\t\tthis.runCreeps();\r\n\t};\r\n\r\n\tthis.runRooms = () => {\r\n\t\tfor (const i in Game.rooms) {\r\n\t\t\tlet room = Game.rooms[i];\r\n\r\n\t\t\tif (room.controller.my) {\r\n\t\t\t\t//console.log(`runRooms room: ${room.name}`);\r\n\r\n\t\t\t\tif (room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\tlet spawnQueueCopy = [];\r\n\r\n\t\t\t\t\troom.memory.spawnQueue.forEach((id) => {\r\n\t\t\t\t\t\tif (Memory.spawnQueueItems[id]) {\r\n\t\t\t\t\t\t\tspawnQueueCopy.push(id);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\troom.memory.spawnQueue = spawnQueueCopy;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet sources = room.find(FIND_SOURCES);\r\n\t\t\t\t//console.log('after finding sources');\r\n\t\t\t\tif (!sources) {\r\n\t\t\t\t\tconsole.log(`runRooms: no sources found! room: ${room.name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//console.log(`runRooms: no. sources found: ${sources.length}`);\r\n\t\t\t\t\tfor (let j = 0; j < sources.length; j++) {\r\n\t\t\t\t\t\tlet source = sources[j];\r\n\t\t\t\t\t\t//console.log(`runRooms | source: ${source.id}`);\r\n\r\n\t\t\t\t\t\tif (!Memory.sources[source.id]) {\r\n\t\t\t\t\t\t\tconst accessPos = this.getAccessiblePositions(source.pos);\r\n\t\t\t\t\t\t\tMemory.sources[source.id] = {\r\n\t\t\t\t\t\t\t\tnoOfAccessPos: accessPos.length,\r\n\t\t\t\t\t\t\t\tcreepsAssigned: 0,\r\n\t\t\t\t\t\t\t\tcreepsPending: 0,\r\n\t\t\t\t\t\t\t\tcreepIds: {},\r\n\t\t\t\t\t\t\t\tpendingCreepIds: {},\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar sourceMemory = Memory.sources[source.id];\r\n\r\n\t\t\t\t\t\tif (!sourceMemory.creepIds) {\r\n\t\t\t\t\t\t\tsourceMemory.creepIds = {};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// clean up dead creeps from source memory\r\n\t\t\t\t\t\tfor (const name in sourceMemory.creepIds) {\r\n\t\t\t\t\t\t\tvar creepname = sourceMemory.creepIds[name];\r\n\t\t\t\t\t\t\tlet creep = Game.creeps[creepname];\r\n\r\n\t\t\t\t\t\t\tif (!creep) {\r\n\t\t\t\t\t\t\t\tdelete sourceMemory.creepIds[name];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar noCreepIds = Object.keys(sourceMemory.creepIds).length;\r\n\r\n\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// check for any defunct pending creeps\r\n\t\t\t\t\t\t\tfor (const id in sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\tif (!Memory.spawnQueueItems[sourceMemory.pendingCreepIds[id]]) {\r\n\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[id];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar creepsPending = Object.keys(sourceMemory.pendingCreepIds),\r\n\t\t\t\t\t\t\tnoCreepsRequired = sourceMemory.noOfAccessPos - noCreepIds;\r\n\r\n\t\t\t\t\t\t// console.log(\r\n\t\t\t\t\t\t// \t`source run. noCreepsRequired ${noCreepsRequired} | noOfAccessPos ${sourceMemory.noOfAccessPos} | noCreepIds ${noCreepIds} | creepsPending ${creepsPending}`\r\n\t\t\t\t\t\t// );\r\n\r\n\t\t\t\t\t\tfor (var q = 0; q < noCreepsRequired; q++) {\r\n\t\t\t\t\t\t\tlet creep = this.creepRequisitioner.getIdleCreep(source.room, CREEP_TYPES.UTILITY, {\r\n\t\t\t\t\t\t\t\trole: CREEP_ROLES.HARVESTER,\r\n\t\t\t\t\t\t\t\tsourceId: source.id,\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tif (creep) {\r\n\t\t\t\t\t\t\t\tsourceMemory.creepIds[creep.name] = creep.name;\r\n\t\t\t\t\t\t\t\tnoCreepIds++;\r\n\t\t\t\t\t\t\t\tlet spawnQueueItemId = creepsPending.shift(); //get first pending id\r\n\t\t\t\t\t\t\t\tif (Memory.spawnQueueItems[spawnQueueItemId]) {\r\n\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t\tdelete Memory.spawnQueueItems[spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet noCreepsPending = creepsPending.length;\r\n\r\n\t\t\t\t\t\tif (sourceMemory.noOfAccessPos > noCreepsPending + noCreepIds) {\r\n\t\t\t\t\t\t\t// console.log(\r\n\t\t\t\t\t\t\t// \t`sourceMemory.noOfAccessPos:${sourceMemory.noOfAccessPos} > sourceMemory.creepsPending:${sourceMemory.creepsPending}`\r\n\t\t\t\t\t\t\t// );\r\n\r\n\t\t\t\t\t\t\twhile (noCreepsPending + noCreepIds < sourceMemory.noOfAccessPos) {\r\n\t\t\t\t\t\t\t\tlet spawnQueueItem = this.creepRequisitioner.addCreepToRoomSpawnQueue(source.room, CREEP_TYPES.UTILITY, {\r\n\t\t\t\t\t\t\t\t\trole: CREEP_ROLES.HARVESTER,\r\n\t\t\t\t\t\t\t\t\tsourceId: source.id,\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// if response exists but isn't spawning resonse (1) must have found idle creep\r\n\t\t\t\t\t\t\t\tif (spawnQueueItem) {\r\n\t\t\t\t\t\t\t\t\t//console.log(`spawnQueueItem: ${JSON.stringify(spawnQueueItem)}`);\r\n\t\t\t\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds[spawnQueueItem.id] = spawnQueueItem.id;\r\n\t\t\t\t\t\t\t\t\tnoCreepsPending++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tconsole.log(`No spawn queue Item found!`);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tMemory.sources[source.id] = sourceMemory;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet spawns = room.find(FIND_MY_STRUCTURES, {\r\n\t\t\t\t\tfilter: { structureType: STRUCTURE_SPAWN },\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (!spawns) {\r\n\t\t\t\t\tconsole.log(`runRooms: No spawns found! room: ${room.name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\t\tconsole.log('spawn queue logic');\r\n\t\t\t\t\t\tfor (let i = 0; i < spawns.length; i++) {\r\n\t\t\t\t\t\t\tlet spawn = spawns[i];\r\n\r\n\t\t\t\t\t\t\tconsole.log(`found spawn ${spawn.id}`);\r\n\r\n\t\t\t\t\t\t\tif (!spawn.memory.creepToSpawn && room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\t\t\t\tconsole.log('adding creepToSpawn from spawn Queue');\r\n\t\t\t\t\t\t\t\tspawn.memory.creepToSpawn = room.memory.spawnQueue.shift();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (spawn.memory.creepToSpawn) {\r\n\t\t\t\t\t\t\t\tconsole.log(`spawn memory creepToSpawn ${spawn.memory.creepToSpawn}`);\r\n\t\t\t\t\t\t\t\tlet spawnQueueItem = Memory.spawnQueueItems[spawn.memory.creepToSpawn];\r\n\r\n\t\t\t\t\t\t\t\tif (spawnQueueItem) {\r\n\t\t\t\t\t\t\t\t\tconsole.log(`processing creep to spawn: ${JSON.stringify(spawn.memory.creepToSpawn)}`);\r\n\t\t\t\t\t\t\t\t\tconst creepBodyResponse = this.getCreepBody(spawnQueueItem.type, spawn.room.energyCapacityAvailable);\r\n\t\t\t\t\t\t\t\t\t// console.log('creep body type result:');\r\n\t\t\t\t\t\t\t\t\t// console.log(JSON.stringify(creepBodyResponse));\r\n\r\n\t\t\t\t\t\t\t\t\tconst spawnCapacityUsed = spawn.store.getUsedCapacity(RESOURCE_ENERGY);\r\n\t\t\t\t\t\t\t\t\tif (creepBodyResponse.cost > spawnCapacityUsed) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`not enough energy to spawnCreep | cost:${creepBodyResponse.cost} | energy:${spawnCapacityUsed}`);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (!this.resource.getStructureResourceOrderId(spawn, RESOURCE_ENERGY)) {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.resource.createResourceOrder(\r\n\t\t\t\t\t\t\t\t\t\t\t\troom,\r\n\t\t\t\t\t\t\t\t\t\t\t\tspawn.id,\r\n\t\t\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\t\t\tcreepBodyResponse.cost - spawnCapacityUsed\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tspawnQueueItem.memory.type = spawnQueueItem.type;\r\n\t\t\t\t\t\t\t\t\t\tvar spawnCreepResult = spawn.spawnCreep(creepBodyResponse.creepBody, this.getNextCreepName(), {\r\n\t\t\t\t\t\t\t\t\t\t\tmemory: spawnQueueItem.memory,\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`spawnCreepResult: ${spawnCreepResult}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// doesn't exist any more to delete\r\n\t\t\t\t\t\t\t\t\tconsole.log('Did not find creep to spawn');\r\n\t\t\t\t\t\t\t\t\tdelete spawn.memory.creepToSpawn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.runCreeps = () => {\r\n\t\t//console.log(`No. of creeps: ${Object.keys(Game.creeps).length}`);\r\n\r\n\t\tfor (const name in Game.creeps) {\r\n\t\t\tlet creep = Game.creeps[name];\r\n\t\t\tif (!creep.memory.role) {\r\n\t\t\t\t//do somehting to reassign creep\r\n\t\t\t\tconsole.log('No creep role found in memory adding to idle pool');\r\n\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t}\r\n\r\n\t\t\tif (!creep.memory.type || creep.memory.type === 'unknown') {\r\n\t\t\t\tcreep.memory.type = CREEP_TYPES.UTILITY;\r\n\t\t\t}\r\n\t\t\tswitch (creep.memory.role) {\r\n\t\t\t\tcase 'idle':\r\n\t\t\t\t\tif (!Memory.idleCreeps[creep.name]) {\r\n\t\t\t\t\t\tconsole.log('No creep name found idle creep memory adding to idle pool');\r\n\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcreep.moveTo(0, 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase CREEP_ROLES.HARVESTER:\r\n\t\t\t\t\tif (!creep.memory.currentAction) {\r\n\t\t\t\t\t\tcreep.store.getFreeCapacity(RESOURCE_ENERGY) < creep.store.getCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t? (creep.memory.currentAction = 'goToSource')\r\n\t\t\t\t\t\t\t: (creep.memory.currentAction = 'goToDestination');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch (creep.memory.currentAction) {\r\n\t\t\t\t\t\tcase 'goToSource':\r\n\t\t\t\t\t\t\tlet source = Game.getObjectById(creep.memory.sourceId);\r\n\r\n\t\t\t\t\t\t\tif (!source) {\r\n\t\t\t\t\t\t\t\tconsole.log(`No source found belonging to id ${creep.memory.sourceId}!`);\r\n\t\t\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// check source\r\n\t\t\t\t\t\t\t\tlet sourceMemory = Memory.sources[source.id];\r\n\t\t\t\t\t\t\t\tif (!sourceMemory.creepIds[creep.name]) {\r\n\t\t\t\t\t\t\t\t\tif (Object.keys(sourceMemory.creepIds).length < sourceMemory.noOfAccessPos) {\r\n\t\t\t\t\t\t\t\t\t\tsourceMemory.creepIds[creep.name] = creep.name;\r\n\t\t\t\t\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (creep.memory.spawnQueueItemId) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (sourceMemory.pendingCreepIds[creep.memory.spawnQueueItemId]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[creep.memory.spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tdelete creep.memory.spawnQueueItemId;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tMemory.sources[source.id] = sourceMemory;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcreep.moveTo(source.pos);\r\n\t\t\t\t\t\t\tif (creep.pos.isNearTo(source.pos)) {\r\n\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'harvest';\r\n\t\t\t\t\t\t\t\tcreep.harvest(Game.getObjectById(creep.memory.sourceId));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'harvest':\r\n\t\t\t\t\t\t\tif (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\r\n\t\t\t\t\t\t\t\tcreep.harvest(Game.getObjectById(creep.memory.sourceId));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (!creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\t\tthis.resource.findNextResourceOrderToFulfill(\r\n\t\t\t\t\t\t\t\t\t\tcreep.room,\r\n\t\t\t\t\t\t\t\t\t\tcreep,\r\n\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\tcreep.store.getUsedCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToDestination';\r\n\t\t\t\t\t\t\t\tlet destination = this.resource.getResourceOrderItemDestination(creep.memory.resourceOrderItemId);\r\n\t\t\t\t\t\t\t\tcreep.moveTo(destination.pos);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'goToDestination':\r\n\t\t\t\t\t\t\tif (!creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\tif (creep.store.getFreeCapacity(RESOURCE_ENERGY) !== 0) {\r\n\t\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToSource';\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthis.resource.findNextResourceOrderToFulfill(\r\n\t\t\t\t\t\t\t\t\t\tcreep.room,\r\n\t\t\t\t\t\t\t\t\t\tcreep,\r\n\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\tcreep.store.getUsedCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\tlet destination = this.resource.getResourceOrderItemDestination(creep.memory.resourceOrderItemId);\r\n\t\t\t\t\t\t\t\tcreep.moveTo(destination.pos);\r\n\t\t\t\t\t\t\t\tlet isNear = creep.pos.isNearTo(destination.pos);\r\n\r\n\t\t\t\t\t\t\t\tif (isNear) {\r\n\t\t\t\t\t\t\t\t\tif (destination.structureType === STRUCTURE_CONTROLLER) {\r\n\t\t\t\t\t\t\t\t\t\tlet controller = destination;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (controller.progress >= controller.progressTotal) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet upgradeResult = creep.upgradeController(controller);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tswitch (upgradeResult) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcase OK:\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(`controller upgrade scheduled successfully in room ${creep.room.name}`);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet transferResult = this.resource.fulfillResourceOrderItem(creep);\r\n\r\n\t\t\t\t\t\t\t\t\tif (transferResult !== OK) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`transferResult: ${transferResult}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToSource';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//clean up creep memory\r\n\t\tfor (const name in Memory.creeps) {\r\n\t\t\tif (!Game.creeps[name]) {\r\n\t\t\t\tdelete Memory.creeps[name];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getAccessiblePositions = (pos) => {\r\n\t\t//console.log('Start App.getAccessiblePositions');\r\n\t\t//test\r\n\t\tif (!pos) {\r\n\t\t\tconsole.log('getAccessiblePositions invalid parameter');\r\n\t\t}\r\n\r\n\t\tvar room = Game.rooms[pos.roomName];\r\n\t\tvar terrain = room.getTerrain();\r\n\t\tvar accessiblePositions = [];\r\n\r\n\t\tlet surroundingPositions = [\r\n\t\t\t{ x: pos.x - 1, y: pos.y - 1 },\r\n\t\t\t{ x: pos.x - 1, y: pos.y },\r\n\t\t\t{ x: pos.x - 1, y: pos.y + 1 },\r\n\t\t\t{ x: pos.x, y: pos.y - 1 },\r\n\t\t\t//{ x: pos.x, y: pos.y },\r\n\t\t\t{ x: pos.x, y: pos.y + 1 },\r\n\t\t\t{ x: pos.x + 1, y: pos.y - 1 },\r\n\t\t\t{ x: pos.x + 1, y: pos.y },\r\n\t\t\t{ x: pos.x + 1, y: pos.y + 1 },\r\n\t\t];\r\n\r\n\t\tsurroundingPositions.forEach((pos) => {\r\n\t\t\tconst terrainGet = terrain.get(pos.x, pos.y);\r\n\t\t\tconst isAccessible = pos.x >= 0 && pos.x <= 49 && pos.y >= 0 && pos.y <= 49 && terrainGet === 0;\r\n\t\t\t//console.log(`terrain.get: ${terrainGet} for ${pos.x},${pos.y} isAccessible: ${isAccessible}`);\r\n\r\n\t\t\tif (isAccessible) {\r\n\t\t\t\taccessiblePositions.push(pos);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn accessiblePositions;\r\n\t};\r\n\r\n\tthis.getNextCreepName = () => {\r\n\t\t//console.log('Start App.getNextCreepName');\r\n\r\n\t\tif (!Memory.settings) {\r\n\t\t\tMemory.settings = {\r\n\t\t\t\tcreepCount: 0,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tMemory.settings.creepCount++;\r\n\r\n\t\treturn `Creep${Memory.settings.creepCount}`;\r\n\t};\r\n\r\n\tthis.getCreepBody = (creepType, availableEnergy) => {\r\n\t\t//console.log('Start App.getCreepBody');\r\n\t\tconst creepTemplate = CREEP_BODIES[creepType];\r\n\t\t//console.log(`creep template: ${JSON.stringify(creepTemplate)}`);\r\n\r\n\t\tlet currentCost = 0,\r\n\t\t\tcreepBodyResponse = {\r\n\t\t\t\tcreepBody: [],\r\n\t\t\t\tbodyCounts: {\r\n\t\t\t\t\tmove: 0,\r\n\t\t\t\t\twork: 0,\r\n\t\t\t\t\tcarry: 0,\r\n\t\t\t\t\tattack: 0,\r\n\t\t\t\t\tranged_attack: 0,\r\n\t\t\t\t\ttough: 0,\r\n\t\t\t\t\theal: 0,\r\n\t\t\t\t\tclaim: 0,\r\n\t\t\t\t\ttotal: 0,\r\n\t\t\t\t},\r\n\t\t\t\tbodyTotal: 0,\r\n\t\t\t\tcost: 0,\r\n\t\t\t};\r\n\r\n\t\tlet ratioCost = 0;\r\n\r\n\t\tfor (const bodyPart in creepTemplate) {\r\n\t\t\t// use spawn max energy to calculate max creep body possible\r\n\t\t\tconst creepTemplateItem = creepTemplate[bodyPart];\r\n\r\n\t\t\t//console.log(`creepTemplateItem: ${JSON.stringify(creepTemplateItem)}`);\r\n\r\n\t\t\tif (creepTemplateItem.value > 0) {\r\n\t\t\t\tlet bodyCost = BODYPART_COST[bodyPart];\r\n\t\t\t\t// e.g. available energy * 0.3\r\n\t\t\t\t//bodyToSpend = availableEnergy * creepTemplateItem.value,\r\n\t\t\t\t// Round down to nearest whole no. as you don't get half a body part.\r\n\t\t\t\t//bodyNo = Math.floor(bodyToSpend / bodyCost);\r\n\t\t\t\t//console.log(`availableEnergy: ${availableEnergy}`);\r\n\t\t\t\t//console.log(`bodyPart: ${bodyPart} | bodyCost: ${bodyCost} | bodyToSpend: ${bodyToSpend} | bodyNo:${bodyNo}`);\r\n\t\t\t\t// if (bodyNo === 0) {\r\n\t\t\t\t// \t// no enough to add body part so return invalid target error\r\n\t\t\t\t// \treturn ERR_INVALID_TARGET;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\t// if (creepTemplateItem.max && bodyNo > creepTemplateItem.max) {\r\n\t\t\t\t// \tbodyNo = creepTemplateItem.max;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tratioCost += bodyCost * creepTemplateItem.value;\r\n\r\n\t\t\t\t// for (let i = 0; i < creepTemplateItem.value; i++) {\r\n\t\t\t\t// \t// creepBodyResponse.creepBody.push(bodyPart);\r\n\t\t\t\t// \t// creepBodyResponse.bodyCounts[bodyPart]++;\r\n\t\t\t\t// \t// creepBodyResponse.bodyTotal++;\r\n\t\t\t\t// \t// creepBodyResponse.cost += bodyCost;\r\n\t\t\t\t// }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet ratio = Math.floor(availableEnergy / ratioCost);\r\n\r\n\t\tif (ratio === 0) {\r\n\t\t\tconsole.log('not enough energy capacity to generate creep template');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (const bodyPart in creepTemplate) {\r\n\t\t\tconst creepTemplateItem = creepTemplate[bodyPart];\r\n\r\n\t\t\tif (creepTemplateItem.value > 0) {\r\n\t\t\t\tcreepBodyResponse.bodyCounts[bodyPart] += ratio;\r\n\t\t\t\tcreepBodyResponse.bodyTotal += ratio;\r\n\r\n\t\t\t\tcreepBodyResponse.cost += BODYPART_COST[bodyPart] * ratio;\r\n\r\n\t\t\t\tfor (var i = 0; i < ratio; i++) {\r\n\t\t\t\t\tcreepBodyResponse.creepBody.push(bodyPart);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn creepBodyResponse;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/common/constants.js":
/*!*********************************!*\
  !*** ./src/common/constants.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** constants.js **/\r\n\r\nmodule.exports = {\r\n\tCOORDINATES_MAX_SIZE: 49,\r\n\tCREEP_ROLES: {\r\n\t\tHARVESTER: \"harvester\",\r\n\t\tSCOUT: \"scout\",\r\n\t},\r\n\tCREEP_TYPES: {\r\n\t\tUTILITY: \"utility\",\r\n\t\tMINER: \"miner\",\r\n\t\tHAULER: \"hauler\",\r\n\t\tCLAIMER: \"claimer\",\r\n\t\tMELEE: \"melee\",\r\n\t\tRANGED: \"ranged\",\r\n\t\tTANK: \"tank\",\r\n\t\tHEALER: \"healer\",\r\n\t},\r\n\tCREEP_BODIES: {\r\n\t\tutility: {\r\n\t\t\tmove: { value: 2 },\r\n\t\t\twork: { value: 1 },\r\n\t\t\tcarry: { value: 1 },\r\n\t\t\tattack: { value: 0 },\r\n\t\t\tranged_attack: { value: 0 },\r\n\t\t\ttough: { value: 0 },\r\n\t\t\theal: { value: 0 },\r\n\t\t\tclaim: { value: 0 },\r\n\t\t},\r\n\t\tminer: {\r\n\t\t\tMOVE: 0.1,\r\n\t\t\tWORK: { value: 0.9, max: 5 },\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t\thauler: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0.5,\r\n\t\t\tATTACK: 0,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t\tclaimer: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0.5,\r\n\t\t},\r\n\t\tmelee: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0.5,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t\tranged: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0,\r\n\t\t\tRANGED_ATTACK: 0.5,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t\ttank: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0.25,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0.25,\r\n\t\t\tHEAL: 0,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t\thealer: {\r\n\t\t\tMOVE: 0.5,\r\n\t\t\tWORK: 0,\r\n\t\t\tCARRY: 0,\r\n\t\t\tATTACK: 0,\r\n\t\t\tRANGED_ATTACK: 0,\r\n\t\t\tTOUGH: 0,\r\n\t\t\tHEAL: 0.5,\r\n\t\t\tCLAIM: 0,\r\n\t\t},\r\n\t},\r\n\tRESOURCE_ORDER_STRUCTURE_PRIORITY: [\r\n\t\t\"spawn\",\r\n\t\t\"storage\",\r\n\t\t\"terminal\",\r\n\t\t\"powerSpawn\",\r\n\t\t\"factory\",\r\n\t\t\"nuker\",\r\n\t\t\"lab\",\r\n\t\t\"extension\",\r\n\t\t\"tower\",\r\n\t\t//STRUCTURE_ROAD,\r\n\t\t//STRUCTURE_WALL,\r\n\t\t//STRUCTURE_RAMPART,\r\n\r\n\t\t//STRUCTURE_CONTAINER,\r\n\t\t//STRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n\t\t//STRUCTURE_PORTAL,\r\n\t\t//STRUCTURE_CONTROLLER,\r\n\t\t//STRUCTURE_LINK,\r\n\r\n\t\t//STRUCTURE_OBSERVER,\r\n\t\t//STRUCTURE_POWER_BANK: \"powerBank\",\r\n\r\n\t\t//STRUCTURE_EXTRACTOR: \"extractor\",\r\n\r\n\t\t//STRUCTURE_INVADER_CORE: \"invaderCore\",\r\n\t],\r\n\tBASE_POSITION_TYPES: {\r\n\t\tCROSS_ROAD: 0,\r\n\t\tCONNECTING_ROAD_ONE: 1,\r\n\t\tCONNECTING_ROAD_TWO: 1,\r\n\t},\r\n\r\n\tDEFAULT_BASE_BLOCK_POSITIONS: {\r\n\t\tCROSS_ROAD: 0,\r\n\t\tCONNECTING_ROAD_ONE: 1,\r\n\t\tCONNECTING_ROAD_TWO: 1,\r\n\t},\r\n};\r\n// global.COORDINATES_MAX_SIZE = 49;\r\n\r\n// global.CREEP_ROLES = {\r\n// \tHARVESTER: \"harvester\",\r\n// \tSCOUT: \"scout\",\r\n// };\r\n\r\n// global.CREEP_TYPES = {\r\n// \tUTILITY: \"utility\",\r\n// \tMINER: \"miner\",\r\n// \tHAULER: \"hauler\",\r\n// \tCLAIMER: \"claimer\",\r\n// \tMELEE: \"melee\",\r\n// \tRANGED: \"ranged\",\r\n// \tTANK: \"tank\",\r\n// \tHEALER: \"healer\",\r\n// };\r\n\r\n// global.CREEP_BODIES = {\r\n// \t[CREEP_TYPES.UTILITY]: {\r\n// \t\tmove: { value: 2 },\r\n// \t\twork: { value: 1 },\r\n// \t\tcarry: { value: 1 },\r\n// \t\tattack: { value: 0 },\r\n// \t\tranged_attack: { value: 0 },\r\n// \t\ttough: { value: 0 },\r\n// \t\theal: { value: 0 },\r\n// \t\tclaim: { value: 0 },\r\n// \t},\r\n// \t[CREEP_TYPES.MINER]: {\r\n// \t\tMOVE: 0.1,\r\n// \t\tWORK: { value: 0.9, max: 5 },\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// \t[CREEP_TYPES.HAULER]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0.5,\r\n// \t\tATTACK: 0,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// \t[CREEP_TYPES.CLAIMER]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0.5,\r\n// \t},\r\n// \t[CREEP_TYPES.MELEE]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0.5,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// \t[CREEP_TYPES.RANGED]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0,\r\n// \t\tRANGED_ATTACK: 0.5,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// \t[CREEP_TYPES.TANK]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0.25,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0.25,\r\n// \t\tHEAL: 0,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// \t[CREEP_TYPES.HEALER]: {\r\n// \t\tMOVE: 0.5,\r\n// \t\tWORK: 0,\r\n// \t\tCARRY: 0,\r\n// \t\tATTACK: 0,\r\n// \t\tRANGED_ATTACK: 0,\r\n// \t\tTOUGH: 0,\r\n// \t\tHEAL: 0.5,\r\n// \t\tCLAIM: 0,\r\n// \t},\r\n// };\r\n\r\n// global.RESOURCE_ORDER_STRUCTURE_PRIORITY = [\r\n// \tSTRUCTURE_SPAWN,\r\n// \tSTRUCTURE_STORAGE,\r\n// \tSTRUCTURE_TERMINAL,\r\n// \tSTRUCTURE_POWER_SPAWN,\r\n// \tSTRUCTURE_FACTORY,\r\n// \tSTRUCTURE_NUKER,\r\n// \tSTRUCTURE_LAB,\r\n// \tSTRUCTURE_EXTENSION,\r\n// \tSTRUCTURE_TOWER,\r\n// \t//STRUCTURE_ROAD,\r\n// \t//STRUCTURE_WALL,\r\n// \t//STRUCTURE_RAMPART,\r\n\r\n// \t//STRUCTURE_CONTAINER,\r\n// \t//STRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n// \t//STRUCTURE_PORTAL,\r\n// \t//STRUCTURE_CONTROLLER,\r\n// \t//STRUCTURE_LINK,\r\n\r\n// \t//STRUCTURE_OBSERVER,\r\n// \t//STRUCTURE_POWER_BANK: \"powerBank\",\r\n\r\n// \t//STRUCTURE_EXTRACTOR: \"extractor\",\r\n\r\n// \t//STRUCTURE_INVADER_CORE: \"invaderCore\",\r\n// ];\r\n\r\n// global.BASE_POSITION_TYPES = {\r\n// \tCROSS_ROAD: 0,\r\n// \tCONNECTING_ROAD_ONE: 1,\r\n// \tCONNECTING_ROAD_TWO: 1,\r\n// };\r\n\n\n//# sourceURL=webpack:///./src/common/constants.js?");

/***/ }),

/***/ "./src/common/debug.js":
/*!*****************************!*\
  !*** ./src/common/debug.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\r\n\tcolorPositionByStructure: (position, structureType) => {\r\n\t\tvar fill = \"#ffffff\";\r\n\r\n\t\tswitch (structureType) {\r\n\t\t\tcase STRUCTURE_SPAWN:\r\n\t\t\t\tfill = \"#ff0000\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_EXTENSION:\r\n\t\t\t\tfill = \"#ffff00\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_STORAGE:\r\n\t\t\t\tfill = \"#999966\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_TOWER:\r\n\t\t\t\tfill = \"#00ff00\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_TERMINAL:\r\n\t\t\t\tfill = \"#000000\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_POWER_SPAWN:\r\n\t\t\t\tfill = \"#ff6666\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_FACTORY:\r\n\t\t\t\tfill = \"#4d4dff\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_NUKER:\r\n\t\t\t\tfill = \"#0000ff\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase STRUCTURE_LAB:\r\n\t\t\t\tfill = \"#cc0099\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tconst style = { radius: 1, fill };\r\n\r\n\t\t//console.log(`coloring position: ${JSON.stringify(pos)}, style: ${style}`);\r\n\r\n\t\tGame.map.visual.circle(position, style);\r\n\t},\r\n};\r\n\n\n//# sourceURL=webpack:///./src/common/debug.js?");

/***/ }),

/***/ "./src/common/helper.js":
/*!******************************!*\
  !*** ./src/common/helper.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tthis.objExists = function (obj) {\r\n\t\treturn typeof obj !== \"undefined\" && obj !== null;\r\n\t};\r\n\r\n\tthis.getCurrentDateTimeAsString = function () {\r\n\t\tvar date = new Date();\r\n\t\tvar sp = \"-\";\r\n\t\tvar dd = date.getDate();\r\n\t\tvar mm = date.getMonth() + 1; //As January is 0.\r\n\t\tvar yyyy = date.getFullYear();\r\n\r\n\t\tif (dd < 10) dd = \"0\" + dd;\r\n\t\tif (mm < 10) mm = \"0\" + mm;\r\n\t\treturn mm + sp + dd + sp + yyyy;\r\n\t};\r\n\r\n\tthis.getFuncName = function (fn) {\r\n\t\tvar f = typeof fn == \"function\";\r\n\t\tvar s = f && ((fn.name && [\"\", fn.name]) || fn.toString().match(/function ([^\\(]+)/));\r\n\t\treturn (!f && \"not a function\") || (s && s[1]) || \"anonymous\";\r\n\t};\r\n\r\n\tthis.getPosName = (x, y) => {\r\n\t\treturn `${x}-${y}`;\r\n\t};\r\n\r\n\tthis.isPosNearEdge = (x, y) => {\r\n\t\treturn x === 0 || x === COORDINATES_MAX_SIZE || y === 0 || y === COORDINATES_MAX_SIZE;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/common/helper.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.loop = function () {\r\n\tvar appConstants = __webpack_require__(/*! ./common/constants */ \"./src/common/constants.js\");\r\n\tglobal = Object.assign(global, appConstants);\r\n\r\n\tthis.attachLogger = (obj) => {\r\n\t\tlet name, fn;\r\n\t\tfor (name in obj) {\r\n\t\t\tfn = obj[name];\r\n\t\t\tif (typeof fn === \"function\") {\r\n\t\t\t\tobj[name] = (function (name, fn) {\r\n\t\t\t\t\tvar args = arguments;\r\n\t\t\t\t\treturn function () {\r\n\t\t\t\t\t\t(function (name, fn) {\r\n\t\t\t\t\t\t\tconsole.log(\"calling \" + name);\r\n\t\t\t\t\t\t}.apply(this, args));\r\n\t\t\t\t\t\treturn fn.apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t})(name, fn);\r\n\t\t\t} else if (typeof fn === \"object\") {\r\n\t\t\t\tthis.attachLogger(fn, true);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconsole.settings = { debug: true };\r\n\r\n\tglobal.debug = __webpack_require__(/*! ./common/debug */ \"./src/common/debug.js\");\r\n\r\n\tconst App = __webpack_require__(/*! ./app.js */ \"./src/app.js\");\r\n\tlet app = new App();\r\n\r\n\tconst RoomSurveyor = __webpack_require__(/*! ./modules/roomSurveyor */ \"./src/modules/roomSurveyor.js\");\r\n\tlet roomSurveyor = new RoomSurveyor(Memory, Game);\r\n\r\n\tif (console.settings.debug) {\r\n\t\tconsole._log = console.log;\r\n\t\tconsole.log = (message) => {\r\n\t\t\tif (console.settings.debug) {\r\n\t\t\t\tconsole._log(message);\r\n\t\t\t}\r\n\t\t};\r\n\t\t//this.attachLogger(app);\r\n\t\t//this.attachLogger(roomSurveyor);\r\n\t}\r\n\r\n\tconsole.debug = (func) => {\r\n\t\tfunc();\r\n\t};\r\n\r\n\tconsole.log(\"loop start\");\r\n\r\n\ttry {\r\n\t\t//app.run();\r\n\t\tfor (var roomName in Game.rooms) {\r\n\t\t\tlet room = Game.rooms[roomName];\r\n\t\t\troomSurveyor.surveyRoom(room);\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.log(\"An error has occured!\");\r\n\t\tconsole.log(\"message: \" + error.message);\r\n\t\tconsole.log(\"name: \" + error.name);\r\n\t\tconsole.log(\"error occured on file: \" + error.filename + \" line: \" + error.lineNumber + \" column: \" + error.columnNumber);\r\n\t\tconsole.log(\"stacktrace \" + error.stack);\r\n\t\t//console.log(JSON.stringify(error));\r\n\t}\r\n\r\n\tconsole.log(\"loop end\");\r\n};\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modules/creepRequisitioner.js":
/*!*******************************************!*\
  !*** ./src/modules/creepRequisitioner.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tif (!Memory.counts.spawnQueueItems) {\r\n\t\tMemory.counts.spawnQueueItems = 0;\r\n\t}\r\n\r\n\tif (!Memory.spawnQueueItems) {\r\n\t\tMemory.spawnQueueItems = {};\r\n\t}\r\n\r\n\tif (!Memory.idleCreeps) {\r\n\t\tMemory.idleCreeps = {};\r\n\t}\r\n\r\n\tthis.addCreepToIdlePool = (room, creep) => {\r\n\t\tif (!room || !creep) {\r\n\t\t\tconsole.log('addCreepToIdlePool: invalid parameters!');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps) {\r\n\t\t\troom.memory.idleCreeps = {};\r\n\t\t}\r\n\r\n\t\tif (!creep.memory.type) {\r\n\t\t\tconsole.log('addCreepToIdlePool: unknown creep type');\r\n\t\t\tcreep.memory.type = CREEP_TYPES.UTILITY;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps[creep.memory.type]) {\r\n\t\t\troom.memory.idleCreeps[creep.memory.type] = [];\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps[creep.memory.type].includes(creep.name)) {\r\n\t\t\t//console.log('adding creep to idle pool');\r\n\t\t\troom.memory.idleCreeps[creep.memory.type].push(creep.name);\r\n\t\t\tMemory.idleCreeps[creep.name] = creep.name;\r\n\t\t\tcreep.memory.role = 'idle';\r\n\t\t} else {\r\n\t\t\tMemory.idleCreeps[creep.name] = creep.name;\r\n\t\t\t//console.log('creep already in idle pool');\r\n\t\t}\r\n\t};\r\n\r\n\tthis.requestCreep = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('requestCreep: invalid parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet creep = this.getIdleCreep(room, type, memory);\r\n\r\n\t\tif (creep) {\r\n\t\t\treturn creep;\r\n\t\t}\r\n\r\n\t\treturn this.addCreepToRoomSpawnQueue(room, type, memory);\r\n\t};\r\n\r\n\tthis.getIdleCreep = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('getIdleCreep: invalid parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps) {\r\n\t\t\troom.memory.idleCreeps = {};\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet idleCreeps = room.memory.idleCreeps[type];\r\n\r\n\t\tif (!idleCreeps) {\r\n\t\t\tconsole.log(`can not find idleCreeps type in room memory. type ${type} roomMemory: ${JSON.stringify(room.memory.idleCreeps)}`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet idleIndex = 0,\r\n\t\t\tidleLength = idleCreeps.length;\r\n\r\n\t\twhile (idleIndex < idleLength) {\r\n\t\t\tlet idleCreep = idleCreeps.shift();\r\n\r\n\t\t\tlet creep = Game.creeps[idleCreep];\r\n\t\t\tif (creep) {\r\n\t\t\t\tconsole.log(`idle creep found. creep: ${creep.name} type:${type}`);\r\n\t\t\t\tcreep.memory = memory;\r\n\t\t\t\troom.memory.idleCreeps[type] = idleCreeps;\r\n\r\n\t\t\t\tif (Memory.idleCreeps[creep.name]) {\r\n\t\t\t\t\tdelete Memory.idleCreeps[creep.name];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn creep;\r\n\t\t\t}\r\n\r\n\t\t\tidleIndex++;\r\n\t\t}\r\n\t\troom.memory.idleCreeps[type] = idleCreeps;\r\n\r\n\t\tconsole.log(`no idle creep found in idleCreep Queue of type: ${type}`);\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\tthis.addCreepToRoomSpawnQueue = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('addCreepToRoomSpawnQueue: Invalid parameters!');\r\n\t\t}\r\n\r\n\t\tlet spawnQueueItem = {\r\n\t\t\tid: this.getNextSpawnQueueItemId(),\r\n\t\t\troomName: room.name,\r\n\t\t\ttype,\r\n\t\t\tmemory,\r\n\t\t\tspawnId: null,\r\n\t\t};\r\n\r\n\t\t// reference for the creep\r\n\t\tspawnQueueItem.memory.spawnQueueItemId = spawnQueueItem.id;\r\n\r\n\t\tMemory.spawnQueueItems[spawnQueueItem.id] = spawnQueueItem;\r\n\r\n\t\tif (!room.memory.spawnQueue) {\r\n\t\t\troom.memory.spawnQueue = [];\r\n\t\t}\r\n\r\n\t\troom.memory.spawnQueue.push(spawnQueueItem.id);\r\n\r\n\t\treturn spawnQueueItem;\r\n\t};\r\n\r\n\tthis.getNextSpawnQueueItemId = () => {\r\n\t\treturn `sqi${Memory.counts.spawnQueueItems++}`;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/creepRequisitioner.js?");

/***/ }),

/***/ "./src/modules/move.js":
/*!*****************************!*\
  !*** ./src/modules/move.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tthis.findPathTo = (startPos, endPos, disallowContainer, avoidCreeps, noRoads) => {\r\n\t\tif (!startPos || !endPos) {\r\n\t\t\tconsole.log('move.findPathTo: Invalid start or end positions.');\r\n\t\t}\r\n\r\n\t\tlet goal = { pos: endPos, range: 1 };\r\n\r\n\t\treturn PathFinder.search(startPos, goal, {\r\n\t\t\t// We need to set the defaults costs higher so that we\r\n\t\t\t// can set the road cost lower in `roomCallback`\r\n\t\t\tplainCost: noRoads ? 1 : 2,\r\n\t\t\tswampCost: 10,\r\n\r\n\t\t\troomCallback: function (roomName) {\r\n\t\t\t\tlet room = Game.rooms[roomName];\r\n\t\t\t\t// In this example `room` will always exist, but since\r\n\t\t\t\t// PathFinder supports searches which span multiple rooms\r\n\t\t\t\t// you should be careful!\r\n\t\t\t\tif (!room) return;\r\n\t\t\t\tlet costs = new PathFinder.CostMatrix();\r\n\r\n\t\t\t\troom.find(FIND_STRUCTURES).forEach(function (struct) {\r\n\t\t\t\t\tif (struct.structureType === STRUCTURE_ROAD && noRoads) {\r\n\t\t\t\t\t\t// Favor roads over plain tiles\r\n\t\t\t\t\t\tcosts.set(struct.pos.x, struct.pos.y, 1);\r\n\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t((disallowContainer && struct.structureType === STRUCTURE_CONTAINER) || struct.structureType !== STRUCTURE_CONTAINER) &&\r\n\t\t\t\t\t\t(struct.structureType !== STRUCTURE_RAMPART || !struct.my)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// Can't walk through non-walkable buildings\r\n\t\t\t\t\t\tcosts.set(struct.pos.x, struct.pos.y, 0xff);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Avoid creeps in the room\r\n\t\t\t\tif (avoidCreeps) {\r\n\t\t\t\t\troom.find(FIND_CREEPS).forEach(function (creep) {\r\n\t\t\t\t\t\tcosts.set(creep.pos.x, creep.pos.y, 0xff);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn costs;\r\n\t\t\t},\r\n\t\t});\r\n\t};\r\n\r\n\tthis.getTotalTravelTime = (path, totalBodyCount, totalMove, totalEmptyCarry = 0) => {\r\n\t\tif (!path || !totalBodyCount || !totalMove) {\r\n\t\t\tconsole.log('move.calculateCreepMovement: Invalid paramerers.');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar fatigue = 0,\r\n\t\t\ttotalTime = 0;\r\n\r\n\t\tpath.forEach((pos) => {\r\n\t\t\tvar isSwamp = false,\r\n\t\t\t\tisRoad = false,\r\n\t\t\t\tlook = pos.look();\r\n\r\n\t\t\t// increase by 1 for each tick\r\n\t\t\ttotalTime++;\r\n\r\n\t\t\tif (look) {\r\n\t\t\t\tlook.forEach((item) => {\r\n\t\t\t\t\tif (item.type === 'terrain' && item.terrain === 'swamp') {\r\n\t\t\t\t\t\tisSwamp = true;\r\n\t\t\t\t\t} else if (item.type === 'structure' && item.structureType === STRUCTURE_ROAD) {\r\n\t\t\t\t\t\tisRoad = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet weight = totalBodyCount - (totalMove + totalEmptyCarry);\r\n\t\t\t\tlet terrainFactor = isSwamp ? 4 : 2;\r\n\t\t\t\tlet roadFactor = isRoad ? 0.5 : 0;\r\n\t\t\t\tlet fatigue = weight * (terrainFactor / roadFactor);\r\n\t\t\t\tconst recovery = totalMove * 2;\r\n\r\n\t\t\t\tconst recoveryTime = floor(fatigue / recovery);\r\n\t\t\t\ttotalTime + recoveryTime;\r\n\r\n\t\t\t\t//F = 2 * (W * K - M)\r\n\t\t\t\t// Where:\r\n\t\t\t\t// \tF = initial fatigue value\r\n\t\t\t\t// \tW = creep weight (Number of body parts, excluding MOVE and empty CARRY parts)\r\n\t\t\t\t// \tK = terrain factor (0.5x for road, 1x for plain, 5x for swamp)\r\n\t\t\t\t// \tM = number of MOVE parts\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn totalTime;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/move.js?");

/***/ }),

/***/ "./src/modules/resource.js":
/*!*********************************!*\
  !*** ./src/modules/resource.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* resource.js */\r\nmodule.exports = function () {\r\n\tif (!Memory.resourceOrders) {\r\n\t\tMemory.resourceOrders = {};\r\n\t}\r\n\r\n\tif (!Memory.resourceOrderItems) {\r\n\t\tMemory.resourceOrderItems = {};\r\n\t}\r\n\r\n\tfor (const i in Memory.resourceOrders) {\r\n\t\tlet resourceOrder;\r\n\t}\r\n\r\n\tthis.createResourceOrder = (room, destinationId, type, amount) => {\r\n\t\tif (!room || !type || !amount) {\r\n\t\t\tconsole.log('createResourceOrder: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t//console.log(`createResourceOrder: ${JSON.stringify({ room, destinationId, type, amount })})`);\r\n\r\n\t\tconst destination = Game.getObjectById(destinationId);\r\n\r\n\t\tif (!destination) {\r\n\t\t\tconsole.log(`createResourceOrder: Couldn't find destination for id: ${destinationId}`);\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders) {\r\n\t\t\troom.memory.resourceOrders = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type]) {\r\n\t\t\troom.memory.resourceOrders[type] = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type][destination.structureType]) {\r\n\t\t\troom.memory.resourceOrders[type][destination.structureType] = [];\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = {\r\n\t\t\tid: this.getNextResourceOrderId(),\r\n\t\t\tdestinationId,\r\n\t\t\ttype,\r\n\t\t\tamount,\r\n\t\t\tamountPending: 0,\r\n\t\t\tamountFulfilled: 0,\r\n\t\t\torderItemIds: {},\r\n\t\t\tcreatedTime: Game.time,\r\n\t\t};\r\n\r\n\t\tif (!Memory[destination.structureType]) {\r\n\t\t\tMemory[destination.structureType] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[destination.structureType][destination.id]) {\r\n\t\t\tMemory[destination.structureType][destination.id] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[destination.structureType][destination.id].resourceOrderIds) {\r\n\t\t\tMemory[destination.structureType][destination.id].resourceOrderIds = {};\r\n\t\t}\r\n\r\n\t\tif (destination.structureType !== STRUCTURE_CONTROLLER && Memory[destination.structureType][destination.id].resourceOrderIds[type]) {\r\n\t\t\tlet orderId = Memory[destination.structureType][destination.id].resourceOrderIds[type];\r\n\t\t\tlet existingOrder = Memory.resourceOrders[orderId];\r\n\r\n\t\t\t// if it exists there has been an issue with making another order at the structure side\r\n\t\t\tif (existingOrder) {\r\n\t\t\t\tconsole.log(`found existing resource order id: ${existingOrder.id}`);\r\n\t\t\t\treturn existingOrder;\r\n\t\t\t} //else continue as normal as it will be overridden anyways\r\n\t\t}\r\n\r\n\t\tMemory.resourceOrders[resourceOrder.id] = resourceOrder;\r\n\r\n\t\troom.memory.resourceOrders[type][destination.structureType].push(resourceOrder.id);\r\n\r\n\t\tMemory[destination.structureType][destination.id].resourceOrderIds[type] = resourceOrder.id;\r\n\r\n\t\treturn resourceOrder;\r\n\t};\r\n\r\n\tthis.findNextResourceOrderToFulfill = (room, creep, type, amount) => {\r\n\t\tif (!room || !creep || !type || !amount) {\r\n\t\t\tconsole.log('findNextResourceOrderToFulfill: Invalid parameters');\r\n\t\t}\r\n\r\n\t\tthis.checkRoomForResourceOrder(room, type);\r\n\r\n\t\tvar strucIndex = 0,\r\n\t\t\torder = null;\r\n\t\tconsole.log(`looking for strucIndex: ${strucIndex}, RESOURCE_ORDER_STRUCTURE_PRIORITY length: ${RESOURCE_ORDER_STRUCTURE_PRIORITY.length}`);\r\n\r\n\t\t//for(var strucIndex = 0; strucIndex < RESOURCE_ORDER_STRUCTURE_PRIORITY.length )\r\n\r\n\t\twhile (!order && strucIndex < RESOURCE_ORDER_STRUCTURE_PRIORITY.length) {\r\n\t\t\tconst structure = RESOURCE_ORDER_STRUCTURE_PRIORITY[strucIndex];\r\n\r\n\t\t\tconsole.log(\r\n\t\t\t\t`looking for ${structure}, strucIndex: ${strucIndex}, RESOURCE_ORDER_STRUCTURE_PRIORITY length: ${RESOURCE_ORDER_STRUCTURE_PRIORITY.length}`\r\n\t\t\t);\r\n\r\n\t\t\tif (!room.memory.resourceOrders[type][structure]) {\r\n\t\t\t\troom.memory.resourceOrders[type][structure] = [];\r\n\t\t\t}\r\n\r\n\t\t\tif (room.memory.resourceOrders[type][structure].length) {\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t`room resourceOrder of type: ${type}, of struc: ${structure}, length: ${room.memory.resourceOrders[type][structure].length}`\r\n\t\t\t\t);\r\n\t\t\t\tvar queueIndex = 0;\r\n\t\t\t\twhile (!order && queueIndex < room.memory.resourceOrders[type][structure].length) {\r\n\t\t\t\t\tvar orderId = room.memory.resourceOrders[type][structure][queueIndex];\r\n\r\n\t\t\t\t\tconsole.log(`looking for order with id ${orderId}, queueIndex: ${queueIndex}`);\r\n\r\n\t\t\t\t\tvar currentOrder = Memory.resourceOrders[orderId];\r\n\r\n\t\t\t\t\tif (!currentOrder) {\r\n\t\t\t\t\t\troom.memory.resourceOrders[type][structure].shift();\r\n\t\t\t\t\t} else if (currentOrder.amountPending + currentOrder.amountFulfilled < currentOrder.amount) {\r\n\t\t\t\t\t\torder = currentOrder;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tqueueIndex++;\r\n\t\t\t\t}\r\n\t\t\t\tqueue = room.memory.resourceOrders[type][structure];\r\n\t\t\t}\r\n\t\t\t//test\r\n\t\t\tstrucIndex++;\r\n\t\t}\r\n\r\n\t\tif (!order) {\r\n\t\t\tif (type === RESOURCE_ENERGY) {\r\n\t\t\t\t// for now go to controller this will probably need to chnage to include other destinations\r\n\t\t\t\torder = this.createResourceOrder(room, room.controller.id, type, amount);\r\n\t\t\t} else {\r\n\t\t\t\t//TODO stick it in storage;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log(`findNextResourceOrderToFulfill: order: ${JSON.stringify(order)}`);\r\n\r\n\t\tlet item = this.createResourceOrderItem(creep, type, amount, order);\r\n\r\n\t\treturn item;\r\n\t};\r\n\r\n\tthis.checkRoomForResourceOrder = (room, type) => {\r\n\t\tif (!room || !type) {\r\n\t\t\tconsole.log('checkRoomForResourceOrder: Invalid parameters');\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders) {\r\n\t\t\troom.memory.resourceOrders = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type]) {\r\n\t\t\troom.memory.resourceOrders[type] = {};\r\n\t\t}\r\n\t};\r\n\r\n\tthis.createResourceOrderItem = (creep, type, amount, order) => {\r\n\t\tif (!creep || !type || !amount || !order) {\r\n\t\t\tconsole.log('createResourceOrderItem: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst amountLeft = order.amount - (order.amountPending + order.amountFulfilled);\r\n\r\n\t\tif (amountLeft <= 0) {\r\n\t\t\tconsole.log('createResourceOrderItem: amountLeft is less than originally requested!');\r\n\t\t\tthis.deleteOrder(order);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// check if it's the full creep carry amount to be fulfilled\r\n\t\tconst amountToUpdate = amount > amountLeft ? amountLeft : amount;\r\n\r\n\t\tlet resourceOrderItem = {\r\n\t\t\tid: this.getNextResourceOrderItemId(),\r\n\t\t\tamount: amountToUpdate,\r\n\t\t\ttype,\r\n\t\t\torderId: order.id,\r\n\t\t\tcreepName: creep.name,\r\n\t\t\tfulfilled: false,\r\n\t\t\tcreatedTime: Game.time,\r\n\t\t};\r\n\r\n\t\tconsole.log(`createResourceOrderItem: order: ${JSON.stringify(order)}`);\r\n\r\n\t\torder.amountPending += amountToUpdate;\r\n\t\torder.orderItemIds[resourceOrderItem.id] = resourceOrderItem.id;\r\n\r\n\t\tMemory.resourceOrders[order.id] = order;\r\n\t\tMemory.resourceOrderItems[resourceOrderItem.id] = resourceOrderItem;\r\n\t\tcreep.memory.resourceOrderItemId = resourceOrderItem.id;\r\n\r\n\t\treturn resourceOrderItem;\r\n\t};\r\n\r\n\tthis.fulfillResourceOrderItem = (creep) => {\r\n\t\tlet orderItem = Memory.resourceOrderItems[creep.memory.resourceOrderItemId];\r\n\r\n\t\tif (!orderItem) {\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\treturn false;\r\n\t\t\t// reassign creep to new order?\r\n\t\t\t// how to determine room etc?\r\n\t\t\t//this.findNextResourceOrderToFulfill(creep)\r\n\t\t}\r\n\r\n\t\tlet order = Memory.resourceOrders[orderItem.orderId];\r\n\r\n\t\tif (!order) {\r\n\t\t\tconsole.log('fulfillResourceOrderItem: could not find order to fulfill!');\r\n\t\t\tdelete Memory.resourceOrderItems[creep.memory.resourceOrderItemId];\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet structure = Game.getObjectById(order.destinationId);\r\n\r\n\t\tif (!structure) {\r\n\t\t\tconsole.log('fulfillResourceOrderItem: Could not find structure for  resource order!');\r\n\r\n\t\t\tthis.deleteOrder(order);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet transferResult = creep.transfer(structure, order.type, orderItem.amount);\r\n\r\n\t\tswitch (transferResult) {\r\n\t\t\tcase OK:\r\n\t\t\t\tif (order.amountFulfilled + orderItem.amount >= order.amount) {\r\n\t\t\t\t\tthis.deleteOrder(order);\r\n\t\t\t\t} else {\r\n\t\t\t\t\torderItem.fulfilled = true;\r\n\t\t\t\t\torder.amountFulfilled += orderItem.amount;\r\n\t\t\t\t\torder.amountPending -= orderItem.amount;\r\n\r\n\t\t\t\t\tMemory.resourceOrderItems[creep.memory.resourceOrderItemId] = orderItem;\r\n\t\t\t\t\tMemory.resourceOrders[orderItem.orderId] = order;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_NOT_ENOUGH_RESOURCES:\r\n\t\t\t\tthis.checkCreepAmount(creep, orderItem, order);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_FULL:\r\n\t\t\t\tthis.deleteOrder(order);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_NOT_IN_RANGE:\r\n\t\t\t\treturn transferResult;\r\n\t\t\tcase ERR_INVALID_ARGS:\r\n\t\t\t\tthis.checkCreepAmount(creep, orderItem, order);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.checkCreepAmount = (creep, orderItem, order) => {\r\n\t\t// find out what resources you do have\r\n\t\tvar creepAmount = creep.store.getUsedCapacity(order.type);\r\n\r\n\t\t// amend the order item\r\n\t\tif (creepAmount && creepAmount > 0) {\r\n\t\t\torder.amountPending -= creepAmount + orderItem.amount;\r\n\t\t\torderItem.amount = creepAmount;\r\n\t\t\torderItem.fulfilled = true;\r\n\t\t\torder.amountFulfilled += orderItem.amount;\r\n\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\tMemory.resourceOrderItems[creep.memory.resourceOrderItemId] = orderItem;\r\n\t\t\tMemory.resourceOrders[orderItem.orderId] = order;\r\n\t\t} else {\r\n\t\t\t// or delete orderItem if no resources\r\n\t\t\tthis.deleteOrderItem(orderItem);\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getNextResourceOrderId = () => {\r\n\t\tif (!Memory.counts.resourceOrders) {\r\n\t\t\tMemory.counts.resourceOrders = 0;\r\n\t\t}\r\n\t\treturn `ro${Memory.counts.resourceOrders++}`;\r\n\t};\r\n\r\n\tthis.getNextResourceOrderItemId = () => {\r\n\t\tif (!Memory.counts.resourceOrderItems) {\r\n\t\t\tMemory.counts.resourceOrderItems = 0;\r\n\t\t}\r\n\t\treturn `roi${Memory.counts.resourceOrderItems++}`;\r\n\t};\r\n\r\n\tthis.deleteOrderItem = (orderItem) => {\r\n\t\tif (!orderItem) {\r\n\t\t\tconsole.log('deleteOrderItem: Invalid Parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = Memory.resourceOrders[orderItem.orderId];\r\n\r\n\t\tif (resourceOrder) {\r\n\t\t\tif (!resourceOrder.fulfilled) {\r\n\t\t\t\tresourceOrder.pendingAmount -= orderItem.amount;\r\n\t\t\t\tdelete resourceOrder.orderItemIds[orderItem.id];\r\n\t\t\t\tMemory.resourceOrders[orderItem.orderId] = resourceOrder;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet creep = Game.creeps[orderItem.creepName];\r\n\r\n\t\tif (creep) {\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t}\r\n\r\n\t\tif (Memory.resourceOrderItems[orderItem.id]) {\r\n\t\t\tdelete Memory.resourceOrderItems[orderItem.id];\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tthis.deleteOrder = (order) => {\r\n\t\tif (!order) {\r\n\t\t\tconsole.log('deleteOrder: Invalid parameter!');\r\n\t\t}\r\n\r\n\t\tif (order.orderItemIds && order.orderItemIds.length) {\r\n\t\t\torder.orderItemIds.foreach((itemId) => {\r\n\t\t\t\tlet orderItem = Memory.resourceOrderItems[itemId];\r\n\r\n\t\t\t\tif (orderItem) {\r\n\t\t\t\t\tlet creep = Game.creeps[orderItem.creepName];\r\n\r\n\t\t\t\t\tif (creep) {\r\n\t\t\t\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdelete Memory.resourceOrderItems[itemId];\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// need to do a check on actual strucutres indiviudually to check if resourceOrder still exists grr!\r\n\t\tlet struc = Game.getObjectById(order.destinationId);\r\n\r\n\t\tif (struc) {\r\n\t\t\tif (Memory[struc.structureType][struc.id]) {\r\n\t\t\t\tdelete Memory[struc.structureType][struc.id].resourceOrderId;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (Memory.resourceOrders[order.id]) {\r\n\t\t\tdelete Memory.resourceOrders[order.id];\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tthis.getStructureResourceOrderId = (struc, type) => {\r\n\t\tif (!struc || !type) {\r\n\t\t\tconsole.log('getStructureResourceOrderId: Invalid parameters!');\r\n\t\t}\r\n\r\n\t\tif (!Memory[struc.structureType]) {\r\n\t\t\tMemory[struc.structureType] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[struc.structureType][struc.id]) {\r\n\t\t\tMemory[struc.structureType][struc.id] = {};\r\n\t\t}\r\n\r\n\t\tlet strucMemory = Memory[struc.structureType][struc.id];\r\n\r\n\t\tif (!strucMemory.resourceOrderIds) {\r\n\t\t\tstrucMemory.resourceOrderIds = {};\r\n\t\t}\r\n\r\n\t\treturn strucMemory.resourceOrderIds[type];\r\n\t};\r\n\r\n\tthis.getResourceOrderItemDestination = (resourceOrderItemId) => {\r\n\t\tif (!resourceOrderItemId) {\r\n\t\t\tconsole.log('getResourceOrderItemDestination: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrderItem = Memory.resourceOrderItems[resourceOrderItemId];\r\n\r\n\t\tif (!resourceOrderItem) {\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No resource order item found belonging to id: ${resourceOrderItemId}`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = Memory.resourceOrders[resourceOrderItem.orderId];\r\n\r\n\t\tif (!resourceOrder) {\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No resource order found belonging to id: ${resourceOrderItem.orderId}`);\r\n\r\n\t\t\tthis.deleteOrderItem(resourceOrderItem);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet destination = Game.getObjectById(resourceOrder.destinationId);\r\n\r\n\t\tif (!destination) {\r\n\t\t\t// no destination found remove order\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No destination found for resource order belonging to id: ${resourceOrder.destinationId}`);\r\n\t\t\tthis.deleteOrder(resourceOrder);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn destination;\r\n\t};\r\n\r\n\t// find and remove any roi belonging to dead creeps\r\n\tfor (const roi in Memory.resourceOrderItems) {\r\n\t\tlet orderItem = Memory.resourceOrderItems[roi];\r\n\t\tif (!Game.creeps[orderItem.creepName]) {\r\n\t\t\tthis.deleteOrderItem(orderItem);\r\n\t\t}\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/resource.js?");

/***/ }),

/***/ "./src/modules/roomSurveyor.js":
/*!*************************************!*\
  !*** ./src/modules/roomSurveyor.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { STRUCTURE_ROAD } = __webpack_require__(/*! ../testing/constants */ \"./src/testing/constants.js\");\r\n\r\nmodule.exports = function (memory, game) {\r\n\tthis.memory = memory;\r\n\tthis.game = game;\r\n\r\n\tthis.sources = [];\r\n\tthis.minerals = [];\r\n\tthis.exits = [];\r\n\tthis.roomTerrain = null;\r\n\r\n\tvar Helper = __webpack_require__(/*! ../common/helper */ \"./src/common/helper.js\");\r\n\tthis.helper = new Helper();\r\n\r\n\tthis.surveyRoom = function (room) {\r\n\t\t/*\r\n        grade a room on\r\n        - resources (sources, minerals)\r\n        - resource placement (far apart)\r\n        - controller placement in conjunction with resources\r\n        - free space\r\n        - defendability (room accessibility, solid rock placement)\r\n\r\n        approach\r\n        - scan each block in the room\r\n        - determine the best path between resources and controller\r\n        - use that as a basis of base placement\r\n\r\n    */\r\n\r\n\t\t// x, y 0 - 49\r\n\r\n\t\tif (room) {\r\n\t\t\tif (this.memory.roomSurveyData) {\r\n\t\t\t\tthis.roomSurveyData = this.memory.roomSurveyData;\r\n\t\t\t} else {\r\n\t\t\t\tthis.roomSurveyData = {\r\n\t\t\t\t\troom: room.name,\r\n\t\t\t\t\tprogressPos: { x: 0, y: 0 },\r\n\t\t\t\t\texitPathPosCounts: {},\r\n\t\t\t\t\tpositionData: {},\r\n\t\t\t\t\ttotalExits: 0,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlet x = this.roomSurveyData.progressPos.x,\r\n\t\t\t\ty = this.roomSurveyData.progressPos.x;\r\n\r\n\t\t\tif (!this.roomTerrain) {\r\n\t\t\t\tthis.roomTerrain = room.getTerrain();\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(`terrainData = ${JSON.stringify(this.roomTerrain)}`);\r\n\r\n\t\t\tthis.sources = room.find(FIND_SOURCES);\r\n\r\n\t\t\t//console.log(`sources = ${JSON.stringify(this.sources)}`);\r\n\r\n\t\t\tthis.minerals = room.find(FIND_MINERALS);\r\n\r\n\t\t\t//console.log(`minerals = ${JSON.stringify(this.minerals)}`);\r\n\r\n\t\t\tthis.exits = room.find(FIND_EXIT);\r\n\r\n\t\t\t//console.log(`exits = ${JSON.stringify(this.exits)}`);\r\n\r\n\t\t\tthis.roomSurveyData.totalExits = this.exits.length;\r\n\r\n\t\t\tlet increment = 0;\r\n\r\n\t\t\t// scan each position\r\n\t\t\twhile (increment < COORDINATES_MAX_SIZE) {\r\n\t\t\t\t//console.log(`increment = ${JSON.stringify(increment)}`);\r\n\t\t\t\tif (increment === 0) {\r\n\t\t\t\t\t// check position\r\n\r\n\t\t\t\t\t//console.log(`first coordinate ${x}:${y} `);\r\n\t\t\t\t\tvar roomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tincrement++;\r\n\r\n\t\t\t\tx = increment;\r\n\t\t\t\t// check position\r\n\t\t\t\t//console.log(`first coordinate ${x}:${y} `);\r\n\t\t\t\tvar roomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\r\n\t\t\t\ty = increment;\r\n\t\t\t\t//console.log(`second coordinate ${x}:${y} `);\r\n\t\t\t\troomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\r\n\t\t\t\t//console.log(\"setting memory\");\r\n\t\t\t\t//console.log(`increment = ${JSON.stringify(increment)}`);\r\n\t\t\t\tthis.memory.roomSurveyData = this.roomSurveyData;\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(\"setting structure map\");\r\n\t\t\tthis.generateStructureMap(this.roomSurveyData);\r\n\r\n\t\t\tthis.memory.roomSurveyData = this.roomSurveyData;\r\n\r\n\t\t\troom.memory.surveyData = this.roomSurveyData;\r\n\t\t}\r\n\r\n\t\tconsole.log(`roomSurveyData = ${JSON.stringify(this.roomSurveyData)}`);\r\n\t\treturn this.roomSurveyData;\r\n\t};\r\n\r\n\tthis.checkPosition = function (pos) {\r\n\t\t//console.log(`checkPostitionStart pos = ${JSON.stringify(pos)}`);\r\n\t\tlet posSurveyData = {\r\n\t\t\tcanBuild: true,\r\n\t\t\tcanTravel: true,\r\n\t\t\tx: pos.x,\r\n\t\t\ty: pos.y,\r\n\t\t};\r\n\r\n\t\tvar terrainData = this.checkPositionTerrain(pos);\r\n\r\n\t\tposSurveyData = { ...posSurveyData, ...terrainData };\r\n\r\n\t\tif (posSurveyData.canTravel) {\r\n\t\t\tvar distanceData = this.getPositionDistanceData(pos);\r\n\r\n\t\t\tposSurveyData = { ...posSurveyData, ...distanceData };\r\n\t\t}\r\n\r\n\t\treturn posSurveyData;\r\n\t};\r\n\r\n\tthis.checkPositionTerrain = function (pos) {\r\n\t\t//console.log(\"checkPositionTerrain\");\r\n\t\tconst posTerrain = this.roomTerrain.get(pos.x, pos.y);\r\n\t\t//console.log(`posTerrain: ${JSON.stringify(posTerrain)}`);\r\n\t\tswitch (posTerrain) {\r\n\t\t\tcase 0: //plain\r\n\t\t\t\t//console.log(\"checkPositionTerrain Plain\");\r\n\t\t\t\treturn { canBuild: !this.helper.isPosNearEdge(pos.x, pos.y), terrain: \"Plain\" };\r\n\t\t\tcase TERRAIN_MASK_WALL: //wall\r\n\t\t\t\t//console.log(\"checkPositionTerrain Wall\");\r\n\t\t\t\treturn { canBuild: false, canTravel: false, terrain: \"Wall\" };\r\n\t\t\tcase TERRAIN_MASK_SWAMP: //swamp\r\n\t\t\t\t//console.log(\"checkPositionTerrain Swamp\");\r\n\t\t\t\treturn { canBuild: !this.helper.isPosNearEdge(pos.x, pos.y), canTravel: false, terrain: \"Swamp\" };\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getPositionDistanceData = function (pos) {\r\n\t\t//console.log(\"getPositionDistanceData\");\r\n\t\tlet room = this.game.rooms[pos.roomName];\r\n\r\n\t\tlet positionDistanceData = {\r\n\t\t\tdistances: {\r\n\t\t\t\tsources: [],\r\n\t\t\t\tmineral: [],\r\n\t\t\t\tcontroller: [],\r\n\t\t\t\texits: [],\r\n\t\t\t},\r\n\t\t\ttotalDistance: 0,\r\n\t\t\tclosestExit: 0,\r\n\t\t};\r\n\r\n\t\tthis.sources.forEach(function (source) {\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: source.pos, range: 1 });\r\n\t\t\tpositionDistanceData.distances.sources.push({ id: source.id, cost: ret.cost });\r\n\t\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\t\t});\r\n\r\n\t\t//console.log(\"getPositionDistanceData got sources\");\r\n\r\n\t\tthis.minerals.forEach(function (mineral) {\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: mineral.pos, range: 1 });\r\n\t\t\tpositionDistanceData.distances.mineral = { id: mineral.id, cost: ret.cost };\r\n\t\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\t\t});\r\n\r\n\t\t//console.log(\"getPositionDistanceData got minerals\");\r\n\r\n\t\tfor (const i in this.exits) {\r\n\t\t\tconst exit = this.exits[i];\r\n\t\t\t//console.log(`exit: ${JSON.stringify(exit)}`);\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: exit, range: 1 });\r\n\r\n\t\t\tif (ret) {\r\n\t\t\t\tpositionDistanceData.distances.exits.push({ id: this.helper.getPosName(exit.x, exit.y), cost: ret.cost });\r\n\r\n\t\t\t\tif (!positionDistanceData.totalExitDistance) {\r\n\t\t\t\t\tpositionDistanceData.totalExitDistance = 0;\r\n\t\t\t\t}\r\n\t\t\t\tpositionDistanceData.totalExitDistance += ret.cost;\r\n\r\n\t\t\t\tif (positionDistanceData.closestExit === 0) {\r\n\t\t\t\t\tpositionDistanceData.closestExit = ret.cost;\r\n\t\t\t\t} else if (positionDistanceData.closestExit > ret.cost) {\r\n\t\t\t\t\tpositionDistanceData.closestExit = ret.cost;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ret.path) {\r\n\t\t\t\t\tfor (let j in ret.path) {\r\n\t\t\t\t\t\tconst pathPos = ret.path[j];\r\n\t\t\t\t\t\tlet id = this.helper.getPosName(pathPos.x, pathPos.y);\r\n\t\t\t\t\t\tthis.roomSurveyData.exitPathPosCounts[id]\r\n\t\t\t\t\t\t\t? this.roomSurveyData.exitPathPosCounts[id]++\r\n\t\t\t\t\t\t\t: (this.roomSurveyData.exitPathPosCounts[id] = 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(`No path found to exit for ${JSON.stringify(exit)}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//console.log(\"getPositionDistanceData got exits\");\r\n\r\n\t\t//console.log(`pos: ${JSON.stringify(pos)}`);\r\n\t\t//console.log(`roomController: ${JSON.stringify(room.controller)}`);\r\n\r\n\t\tvar ret = PathFinder.search(pos, { pos: room.controller.pos, range: 1 });\r\n\t\tpositionDistanceData.distances.controller = { id: room.controller.id, cost: ret.cost };\r\n\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\r\n\t\t//console.log(\"getPositionDistanceData end\");\r\n\r\n\t\treturn positionDistanceData;\r\n\t};\r\n\r\n\tthis.generateStructureMap = (surveyData) => {\r\n\t\tconst weights = {\r\n\t\t\tspawn: { nearSource: 0.3, nearSources: 0.3, defendability: 0.3, nearController: 0.3 },\r\n\t\t};\r\n\t\t// how to determine best placement\r\n\t\t// find best placement for\r\n\t\t//\r\n\t\t// STRUCTURE_SPAWN: \"spawn\",\r\n\t\t// ideally between sources and preferably in a defensive position near controller\r\n\t\tlet nearestSourceDistance = 1000,\r\n\t\t\tnearestSourceDistancePosId = null,\r\n\t\t\tnearestTotalSourceDistance = 1000,\r\n\t\t\tbestSpawnWeight = 1000,\r\n\t\t\tidealSpawnPosition = null;\r\n\r\n\t\tfor (const i in surveyData.positionData) {\r\n\t\t\tlet positionData = surveyData.positionData[i],\r\n\t\t\t\ttotalSourceDistance = 0,\r\n\t\t\t\tposNearestSourceDistance = 1000;\r\n\r\n\t\t\tif (positionData.canTravel && positionData.canBuild) {\r\n\t\t\t\t//console.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\t\t\t\tpositionData.distances.sources.forEach((distance) => {\r\n\t\t\t\t\t// checking globally nearest source distance\r\n\t\t\t\t\tif (distance.cost < nearestSourceDistance) {\r\n\t\t\t\t\t\tnearestSourceDistance = distance.cost;\r\n\t\t\t\t\t\tposNearestSourceDistance = distance.cost;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// checking locally nearest source distance\r\n\t\t\t\t\tif (distance.cost < posNearestSourceDistance) {\r\n\t\t\t\t\t\tposNearestSourceDistance = distance.cost;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// finding total source distance\r\n\t\t\t\t\ttotalSourceDistance += distance.cost;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet controllerDistance = positionData.distances.controller.cost;\r\n\r\n\t\t\t\tlet exitPathCount = this.getSurroundingPositionExitPathCounts(positionData.x, positionData.y);\r\n\r\n\t\t\t\tconst weightNearestSourceDistance = weights.spawn.nearSource * posNearestSourceDistance,\r\n\t\t\t\t\tweightTotalNearestSourceDistance = weights.spawn.nearSources * totalSourceDistance,\r\n\t\t\t\t\tweightControllerDistance = weights.spawn.nearController * controllerDistance,\r\n\t\t\t\t\tweightDefendability = weights.spawn.defendability * exitPathCount;\r\n\r\n\t\t\t\tlet spawnWeight = weightNearestSourceDistance + weightTotalNearestSourceDistance + weightControllerDistance + weightDefendability;\r\n\r\n\t\t\t\tpositionData.weightNearestSourceDistance = weightNearestSourceDistance;\r\n\t\t\t\tpositionData.weightTotalNearestSourceDistance = weightTotalNearestSourceDistance;\r\n\t\t\t\tpositionData.weightControllerDistance = weightControllerDistance;\r\n\t\t\t\tpositionData.weightDefendability = weightDefendability;\r\n\t\t\t\tpositionData.spawnWeight = spawnWeight;\r\n\r\n\t\t\t\tif (spawnWeight < bestSpawnWeight) {\r\n\t\t\t\t\tbestSpawnWeight = spawnWeight;\r\n\t\t\t\t\tidealSpawnPosition = { id: i, x: positionData.x, y: positionData.y, basePositionType: BASE_POSITION_TYPES.CROSS_ROAD };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!idealSpawnPosition) {\r\n\t\t\tconsole.log(\"generateStructureMap: can not find ideal spawn position!\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//surveyData.structureMap = this.createNewStructureMap();\r\n\t\tsurveyData.structureMap = {};\r\n\r\n\t\tlet structureArray = [];\r\n\t\t//console.log(`RESOURCE_ORDER_STRUCTURE_PRIORITY: ${JSON.stringify(RESOURCE_ORDER_STRUCTURE_PRIORITY)}`);\r\n\t\tfor (const j in RESOURCE_ORDER_STRUCTURE_PRIORITY) {\r\n\t\t\t//console.log(`type: ${JSON.stringify(type)}`);\r\n\t\t\t//console.log(`CONTROLLER_STRUCTURES: ${JSON.stringify(CONTROLLER_STRUCTURES)}`);\r\n\t\t\tconst type = RESOURCE_ORDER_STRUCTURE_PRIORITY[j];\r\n\t\t\tlet structureMax = CONTROLLER_STRUCTURES[type][8];\r\n\r\n\t\t\tfor (var i = 0; i < structureMax; i++) {\r\n\t\t\t\tstructureArray.push(type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.structureArray = structureArray;\r\n\t\tconsole.log(`structureArray: ${JSON.stringify(structureArray)}`);\r\n\r\n\t\tthis.mapStructures(this.structureArray, idealSpawnPosition);\r\n\r\n\t\t// let roadPositionsToCheck = [idealSpawnPosition];\r\n\t\t// let positionsChecked = {};\r\n\r\n\t\t// if (!this.roomSurveyData.structureMap[STRUCTURE_ROAD]) {\r\n\t\t// \tthis.roomSurveyData.structureMap[STRUCTURE_ROAD] = [];\r\n\t\t// }\r\n\r\n\t\t// if (this.structureArray && idealSpawnPosition) {\r\n\t\t// \twhile (this.structureArray && roadPositionsToCheck && roadPositionsToCheck.length > 0) {\r\n\t\t// \t\t//console.log(`positionsToCheck = ${JSON.stringify(positionsToCheck)}`);\r\n\t\t// \t\t// let surroundingPositions = this.getSurroundingPositions(idealSpawnPosition.x, idealSpawnPosition.y);\r\n\r\n\t\t// \t\t// for (const i in surroundingPositions) {\r\n\t\t// \t\t//     var position = surroundingPositions[i];\r\n\t\t// \t\t//     this.assessPosForStructure(idealSpawnPosition.x, idealSpawnPosition.y);\r\n\t\t// \t\t// }\r\n\r\n\t\t// \t\tconst positionToCheck = roadPositionsToCheck.shift();\r\n\r\n\t\t// \t\tif (positionToCheck) {\r\n\t\t// \t\t\t//console.log(`positionToCheck = ${JSON.stringify(positionToCheck)}`);\r\n\r\n\t\t// \t\t\tlet canBePlaced = true,\r\n\t\t// \t\t\t\tid = this.helper.getPosName(positionToCheck.x, positionToCheck.y),\r\n\t\t// \t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t// \t\t\tif (!positionsChecked[id]) {\r\n\t\t// \t\t\t\tpositionsChecked[id] = id;\r\n\r\n\t\t// \t\t\t\t//console.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\r\n\t\t// \t\t\t\tif (positionData) {\r\n\t\t// \t\t\t\t\t// check each surrounding pos to see if you  can build on it\r\n\r\n\t\t// \t\t\t\t\tthis.roomSurveyData.structureMap[STRUCTURE_ROAD].push({ x: positionToCheck.x, y: positionToCheck.y });\r\n\t\t// \t\t\t\t\tglobal.debug.colorPositionByStructure(\r\n\t\t// \t\t\t\t\t\tnew RoomPosition(positionToCheck.x, positionToCheck.y, this.roomSurveyData.room),\r\n\t\t// \t\t\t\t\t\tSTRUCTURE_ROAD\r\n\t\t// \t\t\t\t\t);\r\n\r\n\t\t// \t\t\t\t\tconst surroundingPositions = this.getSurroundingPositions(positionToCheck.x, positionToCheck.y);\r\n\r\n\t\t// \t\t\t\t\tfor (const i in surroundingPositions) {\r\n\t\t// \t\t\t\t\t\t// check is position has been checked or not and add to array to be checked if not\r\n\t\t// \t\t\t\t\t\tconst surroundingPos = surroundingPositions[i],\r\n\t\t// \t\t\t\t\t\t\tsurroundingPosId = this.helper.getPosName(surroundingPos.x, surroundingPos.y);\r\n\r\n\t\t// \t\t\t\t\t\tif (!positionsChecked[surroundingPosId]) {\r\n\t\t// \t\t\t\t\t\t\tconst surroundingPosData = this.roomSurveyData.positionData[surroundingPosId];\r\n\r\n\t\t// \t\t\t\t\t\t\tif (this.isRoadPosition(positionToCheck, surroundingPos)) {\r\n\t\t// \t\t\t\t\t\t\t\t// Road\r\n\t\t// \t\t\t\t\t\t\t\tif (surroundingPosData && surroundingPosData.canTravel) {\r\n\t\t// \t\t\t\t\t\t\t\t\tswitch (positionToCheck.basePositionType) {\r\n\t\t// \t\t\t\t\t\t\t\t\t\tcase BASE_POSITION_TYPES.CROSS_ROAD:\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tsurroundingPos.basePositionType = BASE_POSITION_TYPES.CONNECTING_ROAD_ONE;\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t// \t\t\t\t\t\t\t\t\t\tcase BASE_POSITION_TYPES.CONNECTING_ROAD_ONE:\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tsurroundingPos.basePositionType = BASE_POSITION_TYPES.CONNECTING_ROAD_TWO;\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t// \t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tsurroundingPos.basePositionType = BASE_POSITION_TYPES.CROSS_ROAD;\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t// \t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t// \t\t\t\t\t\t\t\t\tsurroundingPos.parentPos = positionToCheck;\r\n\t\t// \t\t\t\t\t\t\t\t\troadPositionsToCheck.push(surroundingPos);\r\n\t\t// \t\t\t\t\t\t\t\t}\r\n\t\t// \t\t\t\t\t\t\t} else {\r\n\t\t// \t\t\t\t\t\t\t\t// Structure\r\n\t\t// \t\t\t\t\t\t\t\tif (surroundingPosData && surroundingPosData.canBuild) {\r\n\t\t// \t\t\t\t\t\t\t\t\tlet strucType = this.structureArray.shift();\r\n\r\n\t\t// \t\t\t\t\t\t\t\t\tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t// \t\t\t\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t// \t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t// \t\t\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType].push({ x: surroundingPos.x, y: surroundingPos.y });\r\n\t\t// \t\t\t\t\t\t\t\t\tglobal.debug.colorPositionByStructure(\r\n\t\t// \t\t\t\t\t\t\t\t\t\tnew RoomPosition(surroundingPos.x, surroundingPos.y, this.roomSurveyData.room),\r\n\t\t// \t\t\t\t\t\t\t\t\t\tstrucType\r\n\t\t// \t\t\t\t\t\t\t\t\t);\r\n\t\t// \t\t\t\t\t\t\t\t}\r\n\t\t// \t\t\t\t\t\t\t}\r\n\t\t// \t\t\t\t\t\t}\r\n\t\t// \t\t\t\t\t}\r\n\r\n\t\t// \t\t\t\t\t// if (canBePlaced) {\r\n\t\t// \t\t\t\t\t// \tlet strucType = this.structureArray.shift();\r\n\r\n\t\t// \t\t\t\t\t// \tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t// \t\t\t\t\t// \t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t// \t\t\t\t\t// \t}\r\n\r\n\t\t// \t\t\t\t\t// \tthis.roomSurveyData.structureMap[strucType].push({ x: positionToCheck.x, y: positionToCheck.y });\r\n\t\t// \t\t\t\t\t// \tglobal.debug.colorPositionByStructure(\r\n\t\t// \t\t\t\t\t// \t\tnew RoomPosition(positionToCheck.x, positionToCheck.y, this.roomSurveyData.room),\r\n\t\t// \t\t\t\t\t// \t\tstrucType\r\n\t\t// \t\t\t\t\t// \t);\r\n\t\t// \t\t\t\t\t// \t//console.log(`positionData = ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\t\t// \t\t\t\t\t// \t//console.log(`structureMap = ${JSON.stringify(this.roomSurveyData.structureMap)}`);\r\n\t\t// \t\t\t\t\t// \tpositionData.hasStructure = true;\r\n\t\t// \t\t\t\t\t// \tthis.roomSurveyData.positionData[id] = positionData;\r\n\t\t// \t\t\t\t\t// }\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\r\n\t\t// let variance = 0,\r\n\t\t// \tstructuresPlacedCount = 0,\r\n\t\t// \tcurrentX = idealSpawnPosition.x,\r\n\t\t// \tcurrentY = idealSpawnPosition.y,\r\n\t\t// \tstartX = idealSpawnPosition.x,\r\n\t\t// \tstartY = idealSpawnPosition.y,\r\n\t\t// \tpossiblePos = [],\r\n\t\t// \tallPosTraversed = [];\r\n\r\n\t\t// //console.log(`structureArray: ${JSON.stringify(structureArray)}`);\r\n\t\t// //console.log(`idealSpawnPosition: ${JSON.stringify(idealSpawnPosition)}`);\r\n\r\n\t\t// //this.assessPosForStructure(currentX, currentY);\r\n\t\t// //allPosTraversed.push({ x: idealSpawnPosition.x, y: idealSpawnPosition.y });\r\n\t\t// //possiblePos.push({ x: idealSpawnPosition.x, y: idealSpawnPosition.y });\r\n\t\t// structuresPlacedCount++;\r\n\r\n\t\t// if (this.structureArray && idealSpawnPosition) {\r\n\t\t// \twhile (\r\n\t\t// \t\t//structuresPlacedCount < structureArray.length &&\r\n\t\t// \t\tvariance < COORDINATES_MAX_SIZE &&\r\n\t\t// \t\tthis.structureArray\r\n\t\t// \t) {\r\n\t\t// \t\t// get corner pos\r\n\t\t// \t\tstartX++;\r\n\t\t// \t\tstartY++;\r\n\t\t// \t\tcurrentX = startX;\r\n\t\t// \t\tcurrentY = startY;\r\n\t\t// \t\tvariance = variance + 2;\r\n\t\t// \t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\r\n\t\t// \t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\t//increase side length\r\n\r\n\t\t// \t\tfor (var x = 0; x < variance; x++) {\r\n\t\t// \t\t\tcurrentX--;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var y = 0; y < variance; y++) {\r\n\t\t// \t\t\tcurrentY--;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var x = 0; x < variance; x++) {\r\n\t\t// \t\t\tcurrentX++;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var y = 1; y < variance; y++) {\r\n\t\t// \t\t\tcurrentY++;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t// if (possiblePos) {\r\n\t\t// \tconsole.log(`possiblePos: ${JSON.stringify(possiblePos)}`);\r\n\t\t// \tconsole.log(`possiblePos length: ${JSON.stringify(possiblePos.length)}`);\r\n\t\t// }\r\n\r\n\t\t// if (allPosTraversed) {\r\n\t\t// \tconsole.log(`allPosTraversed: ${JSON.stringify(allPosTraversed)}`);\r\n\t\t// \tconsole.log(`allPosTraversed length: ${JSON.stringify(allPosTraversed.length)}`);\r\n\t\t// }\r\n\r\n\t\t//\r\n\t\t// STRUCTURE_POWER_SPAWN: \"powerSpawn\",\r\n\t\t// near spawns\r\n\t\t//\r\n\t\t// STRUCTURE_STORAGE: \"storage\",\r\n\t\t// near spawns\r\n\t\t//\r\n\t\t// STRUCTURE_TERMINAL: \"terminal\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_NUKER: \"nuker\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_LAB: \"lab\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_FACTORY: \"factory\",\r\n\t\t// near labs\r\n\t\t//\r\n\t\t// STRUCTURE_EXTENSION: \"extension\",\r\n\t\t// near spawns & sources\r\n\t\t// STRUCTURE_TOWER: \"tower\",\r\n\t\t// near spawns and extensions\r\n\t\t//\r\n\t\t// STRUCTURE_CONTAINER: \"container\",\r\n\t\t// near source align to nearest storage\r\n\t\t//\r\n\t\t// STRUCTURE_LINK: \"link\",\r\n\t\t// near container at source\r\n\r\n\t\t// STRUCTURE_EXTRACTOR: \"extractor\",\r\n\t\t// STRUCTURE_ROAD: \"road\",\r\n\t\t// STRUCTURE_WALL: \"constructedWall\",\r\n\t\t// STRUCTURE_RAMPART: \"rampart\",\r\n\t\t//\r\n\t\t// STRUCTURE_PORTAL: \"portal\",\r\n\t\t// STRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n\t\t// STRUCTURE_CONTROLLER: \"controller\",\r\n\t\t// STRUCTURE_OBSERVER: \"observer\",\r\n\t\t// STRUCTURE_POWER_BANK: \"powerBank\",\r\n\t\t// STRUCTURE_INVADER_CORE: \"invaderCore\",\r\n\t};\r\n\r\n\tthis.mapStructures = (structureArray, idealSpawnPosition) => {\r\n\t\tlet centrePositions = [idealSpawnPosition];\r\n\t\tlet positionsChecked = {};\r\n\r\n\t\twhile (structureArray && structureArray.length > 0 && centrePositions && centrePositions.length > 0) {\r\n\t\t\tlet centrePosition = centrePositions.shift();\r\n\t\t\tconst centrePositionId = this.helper.getPosName(centrePosition.x, centrePosition.y);\r\n\r\n\t\t\tconst centrePositionData = this.roomSurveyData.positionData[centrePositionId];\r\n\r\n\t\t\tif (centrePositionData && centrePositionData.canTravel) {\r\n\t\t\t\tif (!this.roomSurveyData.structureMap[STRUCTURE_ROAD]) {\r\n\t\t\t\t\tthis.roomSurveyData.structureMap[STRUCTURE_ROAD] = [];\r\n\t\t\t\t}\r\n\t\t\t\tthis.roomSurveyData.structureMap[STRUCTURE_ROAD].push({ x: centrePosition.x, y: centrePosition.y });\r\n\t\t\t\tglobal.debug.colorPositionByStructure(new RoomPosition(centrePosition.x, centrePosition.y, this.roomSurveyData.room), STRUCTURE_ROAD);\r\n\t\t\t}\r\n\r\n\t\t\tconst blockPositions = this.getDefaultBaseTemplatePositionBlock(centrePosition);\r\n\r\n\t\t\tconsole.log(`blockPositions: ${JSON.stringify(blockPositions)}`);\r\n\r\n\t\t\tfor (const i in blockPositions) {\r\n\t\t\t\tconst blockPosition = blockPositions[i],\r\n\t\t\t\t\tblockPositionId = this.helper.getPosName(blockPosition.x, blockPosition.y);\r\n\r\n\t\t\t\tconsole.log(`blockPosition: ${JSON.stringify(blockPosition)}`);\r\n\r\n\t\t\t\tconst blockPositionData = this.roomSurveyData.positionData[blockPositionId];\r\n\r\n\t\t\t\tif (blockPositionData) {\r\n\t\t\t\t\tif (blockPosition.isRoad && blockPositionData.canTravel) {\r\n\t\t\t\t\t\t// add road structure\r\n\t\t\t\t\t\tif (!this.roomSurveyData.structureMap[STRUCTURE_ROAD]) {\r\n\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[STRUCTURE_ROAD] = [];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.roomSurveyData.structureMap[STRUCTURE_ROAD].push({ x: blockPosition.x, y: blockPosition.y });\r\n\t\t\t\t\t\tglobal.debug.colorPositionByStructure(\r\n\t\t\t\t\t\t\tnew RoomPosition(blockPosition.x, blockPosition.y, this.roomSurveyData.room),\r\n\t\t\t\t\t\t\tSTRUCTURE_ROAD\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t// find connecting block centre & add to centrePositions\r\n\t\t\t\t\t\tlet connectingBlockCentrePosition = this.getPositionFromDirection(blockPosition, blockPosition.direction, 2);\r\n\r\n\t\t\t\t\t\tconsole.log(`connectingBlockCentrePosition: ${JSON.stringify(connectingBlockCentrePosition)}`);\r\n\r\n\t\t\t\t\t\tif (connectingBlockCentrePosition) {\r\n\t\t\t\t\t\t\tconst connectingBlockCentrePositionId = this.helper.getPosName(blockPosition.x, blockPosition.y);\r\n\t\t\t\t\t\t\tif (!positionsChecked[connectingBlockCentrePositionId]) {\r\n\t\t\t\t\t\t\t\tcentrePositions.push(connectingBlockCentrePosition);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (blockPositionData && blockPosition.canBuild) {\r\n\t\t\t\t\t\tlet strucType = this.structureArray.shift();\r\n\r\n\t\t\t\t\t\tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType].push({ x: blockPosition.x, y: blockPosition.y });\r\n\t\t\t\t\t\tglobal.debug.colorPositionByStructure(\r\n\t\t\t\t\t\t\tnew RoomPosition(blockPosition.x, blockPosition.y, this.roomSurveyData.room),\r\n\t\t\t\t\t\t\tstrucType\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getDefaultBaseTemplatePositionBlock = (centrePosition) => {\r\n\t\tlet positionArray = [];\r\n\r\n\t\tif (!centrePosition) {\r\n\t\t\treturn positionArray;\r\n\t\t}\r\n\r\n\t\tlet topLeftPosition = this.getPositionFromDirection(centrePosition, TOP_LEFT);\r\n\t\tif (topLeftPosition) {\r\n\t\t\ttopLeftPosition.isRoad = false;\r\n\t\t\tpositionArray.push(topLeftPosition);\r\n\t\t}\r\n\r\n\t\tlet topPosition = this.getPositionFromDirection(centrePosition, TOP);\r\n\t\tif (topPosition) {\r\n\t\t\ttopPosition.isRoad = true;\r\n\t\t\tpositionArray.push(topPosition);\r\n\t\t}\r\n\r\n\t\tlet topRightPosition = this.getPositionFromDirection(centrePosition, TOP_RIGHT);\r\n\t\tif (topRightPosition) {\r\n\t\t\ttopRightPosition.isRoad = false;\r\n\t\t\tpositionArray.push(topRightPosition);\r\n\t\t}\r\n\r\n\t\tlet leftPosition = this.getPositionFromDirection(centrePosition, LEFT);\r\n\t\tif (leftPosition) {\r\n\t\t\tleftPosition.isRoad = true;\r\n\t\t\tpositionArray.push(leftPosition);\r\n\t\t}\r\n\r\n\t\tlet rightPosition = this.getPositionFromDirection(centrePosition, RIGHT);\r\n\t\tif (rightPosition) {\r\n\t\t\trightPosition.isRoad = true;\r\n\t\t\tpositionArray.push(rightPosition);\r\n\t\t}\r\n\r\n\t\tlet bottomLeftPosition = this.getPositionFromDirection(centrePosition, BOTTOM_LEFT);\r\n\t\tif (bottomLeftPosition) {\r\n\t\t\tbottomLeftPosition.isRoad = false;\r\n\t\t\tpositionArray.push(bottomLeftPosition);\r\n\t\t}\r\n\r\n\t\tlet bottomPosition = this.getPositionFromDirection(centrePosition, BOTTOM);\r\n\t\tif (bottomPosition) {\r\n\t\t\tbottomPosition.isRoad = true;\r\n\t\t\tpositionArray.push(bottomPosition);\r\n\t\t}\r\n\r\n\t\tlet bottomRightPosition = this.getPositionFromDirection(centrePosition, BOTTOM_RIGHT);\r\n\t\tif (bottomRightPosition) {\r\n\t\t\tbottomRightPosition.isRoad = false;\r\n\t\t\tpositionArray.push(bottomRightPosition);\r\n\t\t}\r\n\r\n\t\treturn positionArray;\r\n\t};\r\n\r\n\t// this.getConnectingBlockCentrePosition = (position) => {\r\n\t// \tif (!position) {\r\n\t// \t\treturn null;\r\n\t// \t}\r\n\r\n\t// \tlet x = position.x,\r\n\t// \t\ty = position.y;\r\n\r\n\t// \tswitch (position.direction) {\r\n\t// \t\tcase TOP:\r\n\t// \t\t\ty + 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase TOP_RIGHT:\r\n\t// \t\t\tx + 2;\r\n\t// \t\t\ty + 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase RIGHT:\r\n\t// \t\t\tx + 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase BOTTOM_RIGHT:\r\n\t// \t\t\tx + 2;\r\n\t// \t\t\ty - 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase BOTTOM:\r\n\t// \t\t\ty - 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase BOTTOM_LEFT:\r\n\t// \t\t\tx - 2;\r\n\t// \t\t\ty - 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase LEFT:\r\n\t// \t\t\tx - 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tcase TOP_LEFT:\r\n\t// \t\t\tx - 2;\r\n\t// \t\t\ty + 2;\r\n\t// \t\t\tbreak;\r\n\t// \t\tdefault:\r\n\t// \t\t\treturn null;\r\n\t// \t}\r\n\r\n\t// \tif (this.helper.isPosNearEdge(x, y)) {\r\n\t// \t\treturn null;\r\n\t// \t}\r\n\r\n\t// \treturn { x, y, direction };\r\n\t// };\r\n\r\n\tthis.getPositionFromDirection = (originalPos, direction, distance) => {\r\n\t\t//console.log(`getPositionFromDirection: ${JSON.stringify(originalPos)}, ${JSON.stringify(direction)}, ${JSON.stringify(distance)}`);\r\n\r\n\t\tif (!originalPos) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (!distance) {\r\n\t\t\tdistance = 1;\r\n\t\t}\r\n\r\n\t\tlet x = originalPos.x,\r\n\t\t\ty = originalPos.y;\r\n\r\n\t\tswitch (direction) {\r\n\t\t\tcase TOP:\r\n\t\t\t\ty += distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase TOP_RIGHT:\r\n\t\t\t\tx += distance;\r\n\t\t\t\ty += distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase RIGHT:\r\n\t\t\t\tx += distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase BOTTOM_RIGHT:\r\n\t\t\t\tx += distance;\r\n\t\t\t\ty -= distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase BOTTOM:\r\n\t\t\t\ty -= distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase BOTTOM_LEFT:\r\n\t\t\t\tx -= distance;\r\n\t\t\t\ty -= distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase LEFT:\r\n\t\t\t\tx -= distance;\r\n\t\t\t\tbreak;\r\n\t\t\tcase TOP_LEFT:\r\n\t\t\t\tx -= distance;\r\n\t\t\t\ty += distance;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(`return null`);\r\n\t\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (this.helper.isPosNearEdge(x, y)) {\r\n\t\t\tconsole.log(`near edge`);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet returnedPosition = { x, y, direction };\r\n\t\t//console.log(`returnedPosition: ${JSON.stringify(returnedPosition)}`);\r\n\r\n\t\treturn returnedPosition;\r\n\t};\r\n\r\n\tthis.assessPosForStructure = (x, y) => {\r\n\t\t//console.log(`x: ${JSON.stringify(x)}, y:${JSON.stringify(y)}`);\r\n\t\tconst canBePlaced = this.canStructureBePlaced(x, y);\r\n\t\t//console.log(`canBePlaced: ${JSON.stringify(canBePlaced)}`);\r\n\t\treturn canBePlaced;\r\n\t};\r\n\r\n\tthis.canStructureBePlaced = (x, y) => {\r\n\t\tlet surroundingPositions = this.getSurroundingPositions(x, y),\r\n\t\t\tcanBePlaced = true,\r\n\t\t\tid = this.helper.getPosName(x, y),\r\n\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t//console.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\r\n\t\tif (positionData) {\r\n\t\t\t// check each surrounding pos to see if you  can build on it\r\n\t\t\t// need to think of a better way of doing this. Checking surrounding positions to see where the current position is.\r\n\r\n\t\t\tfor (const i in surroundingPositions) {\r\n\t\t\t\tconst pos = surroundingPositions[i];\r\n\t\t\t\tif (!this.doesPositionHaveOtherAccess(pos.x, pos.y)) {\r\n\t\t\t\t\tcanBePlaced = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// surroundingPositions.every((pos) => {\r\n\t\t\t// \tif (this.doesPositionHaveOtherAccess(pos.x, pos.y)) {\r\n\t\t\t// \t\tcanBePlaced = true;\r\n\t\t\t// \t\treturn true;\r\n\t\t\t// \t}\r\n\t\t\t// });\r\n\r\n\t\t\tif (canBePlaced) {\r\n\t\t\t\t// current pos is the top right\r\n\t\t\t\tlet strucType = this.structureArray.shift();\r\n\r\n\t\t\t\tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t\t\t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.roomSurveyData.structureMap[strucType].push({ x, y });\r\n\t\t\t\tconsole.log(`positionData = ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\t\t\t\t//console.log(`structureMap = ${JSON.stringify(this.roomSurveyData.structureMap)}`);\r\n\t\t\t\tpositionData.hasStructure = true;\r\n\t\t\t\tthis.roomSurveyData.positionData[id] = positionData;\r\n\r\n\t\t\t\tglobal.debug.colorPositionByStructure(new RoomPosition(x, y, this.roomSurveyData.room), strucType);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcanBePlaced = false;\r\n\t\t}\r\n\r\n\t\treturn canBePlaced;\r\n\t};\r\n\r\n\tthis.doesPositionHaveOtherAccess = (x, y) => {\r\n\t\tlet surroundingPositions = this.getSurroundingPositions(x, y),\r\n\t\t\thasOtherAccess = false;\r\n\r\n\t\t//console.log(`surroundingPositions: ${JSON.stringify(surroundingPositions)}`);\r\n\r\n\t\tfor (const i in surroundingPositions) {\r\n\t\t\tlet pos = surroundingPositions[i];\r\n\t\t\tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t\t// position that you can travel over , doens't have\r\n\t\t\tif (positionData && positionData.canTravel && !positionData.hasStructure) {\r\n\t\t\t\thasOtherAccess = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// surroundingPositions.every((pos) => {\r\n\t\t// \tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t// \t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t// \t// position that you can travel over , doens't have\r\n\t\t// \tif (positionData && positionData.canTravel && !positionData.hasStructure && pos.x != originX && pos.y != originY) {\r\n\t\t// \t\thasOtherAccess = true;\r\n\t\t// \t\treturn false;\r\n\t\t// \t}\r\n\t\t// });\r\n\r\n\t\treturn hasOtherAccess;\r\n\t};\r\n\r\n\tthis.getSurroundingPositions = (x, y) => {\r\n\t\tlet topPos = { x: x, y: y + 1, direction: TOP },\r\n\t\t\tleftPos = { x: x - 1, y, direction: LEFT },\r\n\t\t\trightPos = { x: x, y: y + 1, direction: RIGHT },\r\n\t\t\tbottomPos = { x: x, y: y - 1, direction: BOTTOM },\r\n\t\t\ttopRightPos = { x: x + 1, y: y + 1, direction: TOP_RIGHT },\r\n\t\t\ttopLeftPos = { x: x - 1, y: y + 1, direction: TOP_LEFT },\r\n\t\t\tbottomLeftPos = { x: x - 1, y: y - 1, direction: BOTTOM_LEFT },\r\n\t\t\tbottomRightPos = { x: x + 1, y: y - 1, direction: BOTTOM_RIGHT };\r\n\r\n\t\treturn [topPos, rightPos, bottomPos, leftPos, topLeftPos, topRightPos, bottomLeftPos, bottomRightPos];\r\n\t};\r\n\r\n\tthis.getStructurePositions = (x, y) => {\r\n\t\tlet topPos = { x: x, y: y + 1, direction: TOP },\r\n\t\t\tleftPos = { x: x - 1, y, direction: LEFT },\r\n\t\t\trightPos = { x: x, y: y + 1, direction: RIGHT },\r\n\t\t\tbottomPos = { x: x, y: y - 1, direction: BOTTOM };\r\n\r\n\t\treturn [topPos, rightPos, bottomPos, leftPos];\r\n\t};\r\n\r\n\tthis.getRoadPositions = (x, y) => {\r\n\t\tlet topRightPos = { x: x + 1, y: y + 1, direction: TOP_RIGHT },\r\n\t\t\ttopLeftPos = { x: x - 1, y: y + 1, direction: TOP_LEFT },\r\n\t\t\tbottomLeftPos = { x: x - 1, y: y - 1, direction: BOTTOM_LEFT },\r\n\t\t\tbottomRightPos = { x: x + 1, y: y - 1, direction: BOTTOM_RIGHT };\r\n\r\n\t\treturn [topLeftPos, topRightPos, bottomLeftPos, bottomRightPos];\r\n\t};\r\n\r\n\tthis.isLinearDirection = (direction) => {\r\n\t\tswitch (direction) {\r\n\t\t\tcase TOP:\r\n\t\t\t\treturn true;\r\n\t\t\tcase TOP_RIGHT:\r\n\t\t\t\treturn false;\r\n\t\t\tcase RIGHT:\r\n\t\t\t\treturn true;\r\n\t\t\tcase BOTTOM_RIGHT:\r\n\t\t\t\treturn false;\r\n\t\t\tcase BOTTOM:\r\n\t\t\t\treturn true;\r\n\t\t\tcase BOTTOM_LEFT:\r\n\t\t\t\treturn false;\r\n\t\t\tcase LEFT:\r\n\t\t\t\treturn true;\r\n\t\t\tcase TOP_LEFT:\r\n\t\t\t\treturn false;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.isRoadPosition = (originalPosition, positionToBeChecked) => {\r\n\t\t// determine previous parent direction\r\n\t\t//var direction = this.getDirectionOfPositionFromPosition(originalPosition, positionToBeChecked);\r\n\t\t// check what type of road\r\n\t\tswitch (originalPosition.basePositionType) {\r\n\t\t\tcase BASE_POSITION_TYPES.CROSS_ROAD:\r\n\t\t\t\treturn this.isLinearDirection(positionToBeChecked.direction);\r\n\t\t\tcase BASE_POSITION_TYPES.CONNECTING_ROAD_ONE:\r\n\t\t\t\treturn originalPosition.direction === positionToBeChecked.direction;\r\n\t\t\tcase BASE_POSITION_TYPES.CONNECTING_ROAD_TWO:\r\n\t\t\t\treturn originalPosition.direction === positionToBeChecked.direction;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// switch (direction) {\r\n\t\t// \tcase TOP:\r\n\t\t// \t\treturn true;\r\n\t\t// \tcase TOP_RIGHT:\r\n\t\t// \t\treturn false;\r\n\t\t// \tcase RIGHT:\r\n\t\t// \t\treturn true;\r\n\t\t// \tcase BOTTOM_RIGHT:\r\n\t\t// \t\treturn false;\r\n\t\t// \tcase BOTTOM:\r\n\t\t// \t\treturn true;\r\n\t\t// \tcase BOTTOM_LEFT:\r\n\t\t// \t\treturn false;\r\n\t\t// \tcase LEFT:\r\n\t\t// \t\treturn true;\r\n\t\t// \tcase TOP_LEFT:\r\n\t\t// \t\treturn false;\r\n\t\t// \tdefault:\r\n\t\t// \t\treturn false;\r\n\t\t// }\r\n\t\t// use direction to determine next road positions\r\n\r\n\t\t// switch (originalPosition.basePositionType) {\r\n\t\t// \tcase BASE_POSITION_TYPES.CROSS_ROAD:\r\n\t\t//         return this.isLinearDirection(positionToBeChecked.direction);\r\n\t\t//     case BASE_POSITION_TYPES.CONNECTING_ROAD_ONE:\r\n\r\n\t\t// }\r\n\t};\r\n\r\n\t// this.getDirectionOfPositionFromPosition = (originalPosition, positionToBeChecked) => {\r\n\t// \tconst x = originalPosition.x - positionToBeChecked.x,\r\n\t// \t\ty = originalPosition.y - positionToBeChecked.y;\r\n\r\n\t// \tif (x === 1 && y === 1) {\r\n\t// \t\treturn BOTTOM_LEFT;\r\n\t// \t} else if (x === 1 && y === 0) {\r\n\t// \t\treturn LEFT;\r\n\t// \t} else if (x === 1 && y === -1) {\r\n\t// \t\treturn TOP_LEFT;\r\n\t// \t} else if (x === 0 && y === 1) {\r\n\t// \t\treturn BOTTOM;\r\n\t// \t} else if (x === 0 && y === -1) {\r\n\t// \t\treturn TOP;\r\n\t// \t} else if (x === -1 && y === -1) {\r\n\t// \t\treturn TOP_RIGHT;\r\n\t// \t} else if (x === -1 && y === 0) {\r\n\t// \t\treturn RIGHT;\r\n\t// \t} else if (x === -1 && y === 1) {\r\n\t// \t\treturn BOTTOM_RIGHT;\r\n\t// \t} else {\r\n\t// \t\treturn -1;\r\n\t// \t}\r\n\t// };\r\n\r\n\tthis.createNewStructureMap = function () {\r\n\t\treturn {\r\n\t\t\tspawn: {},\r\n\t\t\textension: {},\r\n\t\t\troad: {},\r\n\t\t\tconstructedWall: {},\r\n\t\t\trampart: {},\r\n\t\t\tcontroller: {},\r\n\t\t\tlink: {},\r\n\t\t\tstorage: {},\r\n\t\t\ttower: {},\r\n\t\t\tobserver: {},\r\n\t\t\tpowerSpawn: {},\r\n\t\t\textractor: {},\r\n\t\t\tlab: {},\r\n\t\t\tterminal: {},\r\n\t\t\tcontainer: {},\r\n\t\t\tnuker: {},\r\n\t\t};\r\n\t};\r\n\r\n\tthis.getSurroundingPositionExitPathCounts = (x, y) => {\r\n\t\tthis.exitPositions = [\r\n\t\t\t{ x: x - 1, y: -1 },\r\n\t\t\t{ x: x, y: -1 },\r\n\t\t\t{ x: x + 1, y: -1 },\r\n\t\t\t{ x: x - 1, y },\r\n\t\t\t{ x: x + 1, y },\r\n\t\t\t{ x: x - 1, y: +1 },\r\n\t\t\t{ x: x, y: +1 },\r\n\t\t\t{ x: x + 1, y: +1 },\r\n\t\t];\r\n\r\n\t\tlet count = 0;\r\n\r\n\t\tthis.exitPositions.forEach((pos) => {\r\n\t\t\t//console.log(`pos: ${JSON.stringify(pos)}`);\r\n\t\t\tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\t\t\t//console.log(`id: ${JSON.stringify(id)}`);\r\n\t\t\t//console.log(`roomSurveyData.positionData: ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\r\n\t\t\tif (positionData && positionData.canTravel) {\r\n\t\t\t\tvar exitPathPosCount = this.roomSurveyData.exitPathPosCounts[id];\r\n\t\t\t\tif (exitPathPosCount) {\r\n\t\t\t\t\tcount += exitPathPosCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn count;\r\n\t};\r\n\r\n\tthis.identifyRoads = function (room) {\r\n\t\t// find sources and path to controller\r\n\t};\r\n\r\n\tthis.structurePlacement = function (structure) {\r\n\t\t/* structure can only be placed if it's accessible\r\n        what is accessible patterns\r\n        how to define accessible?\r\n        minimal\r\n        - if two free spaces exist\r\n        basic collection\r\n        - three structures and there is enough free space for it still to be accessible\r\n\r\n        we need to track \r\n        - road (mandatory free space) placement \r\n        - structures\r\n        \r\n        How to determine structure placement and order?\r\n        - \r\n\r\n        coordinates\r\n        -------------\r\n        | 1 | 2 | 3 |\r\n        -------------\r\n        | 4 | o | 6 |\r\n        -------------\r\n        | 7 | 8 | 9 | \r\n\t\t-------------\r\n\t\t\r\n\t\t--------------------------\r\n        |  1 |  2 |  3 |  4 |  5 |\r\n        --------------------------\r\n        |  6 |  7 |  8 |  9 | 10 |\r\n        --------------------------\r\n        | 11 | 12 | 13 | 14 | 15 |\r\n\t\t--------------------------\r\n\t\t| 16 | 17 | 18 | 19 | 20 |\r\n\t\t--------------------------\r\n\t\t| 21 | 22 | 23 | 24 | 25 |\r\n\t\t--------------------------\r\n\t\t\r\n\t\t--------------------------\r\n        |  S |  S |  3 |  4 |  5 |\r\n        --------------------------\r\n        |  S |  7 |  8 |  9 | 10 |\r\n        --------------------------\r\n        | 11 | 12 | 13 | 14 | 15 |\r\n\t\t--------------------------\r\n\t\t| 16 | 17 | 18 | 19 | 20 |\r\n\t\t--------------------------\r\n\t\t| 21 | 22 | 23 | 24 | 25 |\r\n        --------------------------\r\n\r\n\r\n    */\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/roomSurveyor.js?");

/***/ }),

/***/ "./src/testing/constants.js":
/*!**********************************!*\
  !*** ./src/testing/constants.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\r\n\tOK: 0,\r\n\tERR_NOT_OWNER: -1,\r\n\tERR_NO_PATH: -2,\r\n\tERR_NAME_EXISTS: -3,\r\n\tERR_BUSY: -4,\r\n\tERR_NOT_FOUND: -5,\r\n\tERR_NOT_ENOUGH_ENERGY: -6,\r\n\tERR_NOT_ENOUGH_RESOURCES: -6,\r\n\tERR_INVALID_TARGET: -7,\r\n\tERR_FULL: -8,\r\n\tERR_NOT_IN_RANGE: -9,\r\n\tERR_INVALID_ARGS: -10,\r\n\tERR_TIRED: -11,\r\n\tERR_NO_BODYPART: -12,\r\n\tERR_NOT_ENOUGH_EXTENSIONS: -6,\r\n\tERR_RCL_NOT_ENOUGH: -14,\r\n\tERR_GCL_NOT_ENOUGH: -15,\r\n\r\n\tFIND_EXIT_TOP: 1,\r\n\tFIND_EXIT_RIGHT: 3,\r\n\tFIND_EXIT_BOTTOM: 5,\r\n\tFIND_EXIT_LEFT: 7,\r\n\tFIND_EXIT: 10,\r\n\tFIND_CREEPS: 101,\r\n\tFIND_MY_CREEPS: 102,\r\n\tFIND_HOSTILE_CREEPS: 103,\r\n\tFIND_SOURCES_ACTIVE: 104,\r\n\tFIND_SOURCES: 105,\r\n\tFIND_DROPPED_RESOURCES: 106,\r\n\tFIND_STRUCTURES: 107,\r\n\tFIND_MY_STRUCTURES: 108,\r\n\tFIND_HOSTILE_STRUCTURES: 109,\r\n\tFIND_FLAGS: 110,\r\n\tFIND_CONSTRUCTION_SITES: 111,\r\n\tFIND_MY_SPAWNS: 112,\r\n\tFIND_HOSTILE_SPAWNS: 113,\r\n\tFIND_MY_CONSTRUCTION_SITES: 114,\r\n\tFIND_HOSTILE_CONSTRUCTION_SITES: 115,\r\n\tFIND_MINERALS: 116,\r\n\tFIND_NUKES: 117,\r\n\tFIND_TOMBSTONES: 118,\r\n\tFIND_POWER_CREEPS: 119,\r\n\tFIND_MY_POWER_CREEPS: 120,\r\n\tFIND_HOSTILE_POWER_CREEPS: 121,\r\n\tFIND_DEPOSITS: 122,\r\n\tFIND_RUINS: 123,\r\n\r\n\tTOP: 1,\r\n\tTOP_RIGHT: 2,\r\n\tRIGHT: 3,\r\n\tBOTTOM_RIGHT: 4,\r\n\tBOTTOM: 5,\r\n\tBOTTOM_LEFT: 6,\r\n\tLEFT: 7,\r\n\tTOP_LEFT: 8,\r\n\r\n\tCOLOR_RED: 1,\r\n\tCOLOR_PURPLE: 2,\r\n\tCOLOR_BLUE: 3,\r\n\tCOLOR_CYAN: 4,\r\n\tCOLOR_GREEN: 5,\r\n\tCOLOR_YELLOW: 6,\r\n\tCOLOR_ORANGE: 7,\r\n\tCOLOR_BROWN: 8,\r\n\tCOLOR_GREY: 9,\r\n\tCOLOR_WHITE: 10,\r\n\r\n\tLOOK_CREEPS: \"creep\",\r\n\tLOOK_ENERGY: \"energy\",\r\n\tLOOK_RESOURCES: \"resource\",\r\n\tLOOK_SOURCES: \"source\",\r\n\tLOOK_MINERALS: \"mineral\",\r\n\tLOOK_DEPOSITS: \"deposit\",\r\n\tLOOK_STRUCTURES: \"structure\",\r\n\tLOOK_FLAGS: \"flag\",\r\n\tLOOK_CONSTRUCTION_SITES: \"constructionSite\",\r\n\tLOOK_NUKES: \"nuke\",\r\n\tLOOK_TERRAIN: \"terrain\",\r\n\tLOOK_TOMBSTONES: \"tombstone\",\r\n\tLOOK_POWER_CREEPS: \"powerCreep\",\r\n\tLOOK_RUINS: \"ruin\",\r\n\r\n\tOBSTACLE_OBJECT_TYPES: [\r\n\t\t\"spawn\",\r\n\t\t\"creep\",\r\n\t\t\"powerCreep\",\r\n\t\t\"source\",\r\n\t\t\"mineral\",\r\n\t\t\"deposit\",\r\n\t\t\"controller\",\r\n\t\t\"constructedWall\",\r\n\t\t\"extension\",\r\n\t\t\"link\",\r\n\t\t\"storage\",\r\n\t\t\"tower\",\r\n\t\t\"observer\",\r\n\t\t\"powerSpawn\",\r\n\t\t\"powerBank\",\r\n\t\t\"lab\",\r\n\t\t\"terminal\",\r\n\t\t\"nuker\",\r\n\t\t\"factory\",\r\n\t\t\"invaderCore\",\r\n\t],\r\n\r\n\tMOVE: \"move\",\r\n\tWORK: \"work\",\r\n\tCARRY: \"carry\",\r\n\tATTACK: \"attack\",\r\n\tRANGED_ATTACK: \"ranged_attack\",\r\n\tTOUGH: \"tough\",\r\n\tHEAL: \"heal\",\r\n\tCLAIM: \"claim\",\r\n\r\n\tBODYPART_COST: {\r\n\t\tmove: 50,\r\n\t\twork: 100,\r\n\t\tattack: 80,\r\n\t\tcarry: 50,\r\n\t\theal: 250,\r\n\t\tranged_attack: 150,\r\n\t\ttough: 10,\r\n\t\tclaim: 600,\r\n\t},\r\n\r\n\t// WORLD_WIDTH and WORLD_HEIGHT constants are deprecated, please use Game.map.getWorldSize() instead\r\n\tWORLD_WIDTH: 202,\r\n\tWORLD_HEIGHT: 202,\r\n\r\n\tCREEP_LIFE_TIME: 1500,\r\n\tCREEP_CLAIM_LIFE_TIME: 600,\r\n\tCREEP_CORPSE_RATE: 0.2,\r\n\tCREEP_PART_MAX_ENERGY: 125,\r\n\r\n\tCARRY_CAPACITY: 50,\r\n\tHARVEST_POWER: 2,\r\n\tHARVEST_MINERAL_POWER: 1,\r\n\tHARVEST_DEPOSIT_POWER: 1,\r\n\tREPAIR_POWER: 100,\r\n\tDISMANTLE_POWER: 50,\r\n\tBUILD_POWER: 5,\r\n\tATTACK_POWER: 30,\r\n\tUPGRADE_CONTROLLER_POWER: 1,\r\n\tRANGED_ATTACK_POWER: 10,\r\n\tHEAL_POWER: 12,\r\n\tRANGED_HEAL_POWER: 4,\r\n\tREPAIR_COST: 0.01,\r\n\tDISMANTLE_COST: 0.005,\r\n\r\n\tRAMPART_DECAY_AMOUNT: 300,\r\n\tRAMPART_DECAY_TIME: 100,\r\n\tRAMPART_HITS: 1,\r\n\tRAMPART_HITS_MAX: { 2: 300000, 3: 1000000, 4: 3000000, 5: 10000000, 6: 30000000, 7: 100000000, 8: 300000000 },\r\n\r\n\tENERGY_REGEN_TIME: 300,\r\n\tENERGY_DECAY: 1000,\r\n\r\n\tSPAWN_HITS: 5000,\r\n\tSPAWN_ENERGY_START: 300,\r\n\tSPAWN_ENERGY_CAPACITY: 300,\r\n\tCREEP_SPAWN_TIME: 3,\r\n\tSPAWN_RENEW_RATIO: 1.2,\r\n\r\n\tSOURCE_ENERGY_CAPACITY: 3000,\r\n\tSOURCE_ENERGY_NEUTRAL_CAPACITY: 1500,\r\n\tSOURCE_ENERGY_KEEPER_CAPACITY: 4000,\r\n\r\n\tWALL_HITS: 1,\r\n\tWALL_HITS_MAX: 300000000,\r\n\r\n\tEXTENSION_HITS: 1000,\r\n\tEXTENSION_ENERGY_CAPACITY: { 0: 50, 1: 50, 2: 50, 3: 50, 4: 50, 5: 50, 6: 50, 7: 100, 8: 200 },\r\n\r\n\tROAD_HITS: 5000,\r\n\tROAD_WEAROUT: 1,\r\n\tROAD_WEAROUT_POWER_CREEP: 100,\r\n\tROAD_DECAY_AMOUNT: 100,\r\n\tROAD_DECAY_TIME: 1000,\r\n\r\n\tLINK_HITS: 1000,\r\n\tLINK_HITS_MAX: 1000,\r\n\tLINK_CAPACITY: 800,\r\n\tLINK_COOLDOWN: 1,\r\n\tLINK_LOSS_RATIO: 0.03,\r\n\r\n\tSTORAGE_CAPACITY: 1000000,\r\n\tSTORAGE_HITS: 10000,\r\n\r\n\tSTRUCTURE_SPAWN: \"spawn\",\r\n\tSTRUCTURE_EXTENSION: \"extension\",\r\n\tSTRUCTURE_ROAD: \"road\",\r\n\tSTRUCTURE_WALL: \"constructedWall\",\r\n\tSTRUCTURE_RAMPART: \"rampart\",\r\n\tSTRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n\tSTRUCTURE_PORTAL: \"portal\",\r\n\tSTRUCTURE_CONTROLLER: \"controller\",\r\n\tSTRUCTURE_LINK: \"link\",\r\n\tSTRUCTURE_STORAGE: \"storage\",\r\n\tSTRUCTURE_TOWER: \"tower\",\r\n\tSTRUCTURE_OBSERVER: \"observer\",\r\n\tSTRUCTURE_POWER_BANK: \"powerBank\",\r\n\tSTRUCTURE_POWER_SPAWN: \"powerSpawn\",\r\n\tSTRUCTURE_EXTRACTOR: \"extractor\",\r\n\tSTRUCTURE_LAB: \"lab\",\r\n\tSTRUCTURE_TERMINAL: \"terminal\",\r\n\tSTRUCTURE_CONTAINER: \"container\",\r\n\tSTRUCTURE_NUKER: \"nuker\",\r\n\tSTRUCTURE_FACTORY: \"factory\",\r\n\tSTRUCTURE_INVADER_CORE: \"invaderCore\",\r\n\r\n\tCONSTRUCTION_COST: {\r\n\t\tspawn: 15000,\r\n\t\textension: 3000,\r\n\t\troad: 300,\r\n\t\tconstructedWall: 1,\r\n\t\trampart: 1,\r\n\t\tlink: 5000,\r\n\t\tstorage: 30000,\r\n\t\ttower: 5000,\r\n\t\tobserver: 8000,\r\n\t\tpowerSpawn: 100000,\r\n\t\textractor: 5000,\r\n\t\tlab: 50000,\r\n\t\tterminal: 100000,\r\n\t\tcontainer: 5000,\r\n\t\tnuker: 100000,\r\n\t\tfactory: 100000,\r\n\t},\r\n\tCONSTRUCTION_COST_ROAD_SWAMP_RATIO: 5,\r\n\tCONSTRUCTION_COST_ROAD_WALL_RATIO: 150,\r\n\r\n\tCONTROLLER_LEVELS: { 1: 200, 2: 45000, 3: 135000, 4: 405000, 5: 1215000, 6: 3645000, 7: 10935000 },\r\n\tCONTROLLER_STRUCTURES: {\r\n\t\tspawn: { 0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 2, 8: 3 },\r\n\t\textension: { 0: 0, 1: 0, 2: 5, 3: 10, 4: 20, 5: 30, 6: 40, 7: 50, 8: 60 },\r\n\t\tlink: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 2, 6: 3, 7: 4, 8: 6 },\r\n\t\troad: { 0: 2500, 1: 2500, 2: 2500, 3: 2500, 4: 2500, 5: 2500, 6: 2500, 7: 2500, 8: 2500 },\r\n\t\tconstructedWall: { 1: 0, 2: 2500, 3: 2500, 4: 2500, 5: 2500, 6: 2500, 7: 2500, 8: 2500 },\r\n\t\trampart: { 1: 0, 2: 2500, 3: 2500, 4: 2500, 5: 2500, 6: 2500, 7: 2500, 8: 2500 },\r\n\t\tstorage: { 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1 },\r\n\t\ttower: { 1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2, 7: 3, 8: 6 },\r\n\t\tobserver: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 1 },\r\n\t\tpowerSpawn: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 1 },\r\n\t\textractor: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 1, 7: 1, 8: 1 },\r\n\t\tterminal: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 1, 7: 1, 8: 1 },\r\n\t\tlab: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 3, 7: 6, 8: 10 },\r\n\t\tcontainer: { 0: 5, 1: 5, 2: 5, 3: 5, 4: 5, 5: 5, 6: 5, 7: 5, 8: 5 },\r\n\t\tnuker: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 1 },\r\n\t\tfactory: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 1, 8: 1 },\r\n\t},\r\n\tCONTROLLER_DOWNGRADE: { 1: 20000, 2: 10000, 3: 20000, 4: 40000, 5: 80000, 6: 120000, 7: 150000, 8: 200000 },\r\n\tCONTROLLER_DOWNGRADE_RESTORE: 100,\r\n\tCONTROLLER_DOWNGRADE_SAFEMODE_THRESHOLD: 5000,\r\n\tCONTROLLER_CLAIM_DOWNGRADE: 300,\r\n\tCONTROLLER_RESERVE: 1,\r\n\tCONTROLLER_RESERVE_MAX: 5000,\r\n\tCONTROLLER_MAX_UPGRADE_PER_TICK: 15,\r\n\tCONTROLLER_ATTACK_BLOCKED_UPGRADE: 1000,\r\n\tCONTROLLER_NUKE_BLOCKED_UPGRADE: 200,\r\n\r\n\tSAFE_MODE_DURATION: 20000,\r\n\tSAFE_MODE_COOLDOWN: 50000,\r\n\tSAFE_MODE_COST: 1000,\r\n\r\n\tTOWER_HITS: 3000,\r\n\tTOWER_CAPACITY: 1000,\r\n\tTOWER_ENERGY_COST: 10,\r\n\tTOWER_POWER_ATTACK: 600,\r\n\tTOWER_POWER_HEAL: 400,\r\n\tTOWER_POWER_REPAIR: 800,\r\n\tTOWER_OPTIMAL_RANGE: 5,\r\n\tTOWER_FALLOFF_RANGE: 20,\r\n\tTOWER_FALLOFF: 0.75,\r\n\r\n\tOBSERVER_HITS: 500,\r\n\tOBSERVER_RANGE: 10,\r\n\r\n\tPOWER_BANK_HITS: 2000000,\r\n\tPOWER_BANK_CAPACITY_MAX: 5000,\r\n\tPOWER_BANK_CAPACITY_MIN: 500,\r\n\tPOWER_BANK_CAPACITY_CRIT: 0.3,\r\n\tPOWER_BANK_DECAY: 5000,\r\n\tPOWER_BANK_HIT_BACK: 0.5,\r\n\r\n\tPOWER_SPAWN_HITS: 5000,\r\n\tPOWER_SPAWN_ENERGY_CAPACITY: 5000,\r\n\tPOWER_SPAWN_POWER_CAPACITY: 100,\r\n\tPOWER_SPAWN_ENERGY_RATIO: 50,\r\n\r\n\tEXTRACTOR_HITS: 500,\r\n\tEXTRACTOR_COOLDOWN: 5,\r\n\r\n\tLAB_HITS: 500,\r\n\tLAB_MINERAL_CAPACITY: 3000,\r\n\tLAB_ENERGY_CAPACITY: 2000,\r\n\tLAB_BOOST_ENERGY: 20,\r\n\tLAB_BOOST_MINERAL: 30,\r\n\tLAB_COOLDOWN: 10, // not used\r\n\tLAB_REACTION_AMOUNT: 5,\r\n\tLAB_UNBOOST_ENERGY: 0,\r\n\tLAB_UNBOOST_MINERAL: 15,\r\n\r\n\tGCL_POW: 2.4,\r\n\tGCL_MULTIPLY: 1000000,\r\n\tGCL_NOVICE: 3,\r\n\r\n\tMODE_SIMULATION: null,\r\n\tMODE_WORLD: null,\r\n\r\n\tTERRAIN_MASK_WALL: 1,\r\n\tTERRAIN_MASK_SWAMP: 2,\r\n\tTERRAIN_MASK_LAVA: 4,\r\n\r\n\tMAX_CONSTRUCTION_SITES: 100,\r\n\tMAX_CREEP_SIZE: 50,\r\n\r\n\tMINERAL_REGEN_TIME: 50000,\r\n\tMINERAL_MIN_AMOUNT: {\r\n\t\tH: 35000,\r\n\t\tO: 35000,\r\n\t\tL: 35000,\r\n\t\tK: 35000,\r\n\t\tZ: 35000,\r\n\t\tU: 35000,\r\n\t\tX: 35000,\r\n\t},\r\n\tMINERAL_RANDOM_FACTOR: 2,\r\n\r\n\tMINERAL_DENSITY: {\r\n\t\t1: 15000,\r\n\t\t2: 35000,\r\n\t\t3: 70000,\r\n\t\t4: 100000,\r\n\t},\r\n\tMINERAL_DENSITY_PROBABILITY: {\r\n\t\t1: 0.1,\r\n\t\t2: 0.5,\r\n\t\t3: 0.9,\r\n\t\t4: 1.0,\r\n\t},\r\n\tMINERAL_DENSITY_CHANGE: 0.05,\r\n\r\n\tDENSITY_LOW: 1,\r\n\tDENSITY_MODERATE: 2,\r\n\tDENSITY_HIGH: 3,\r\n\tDENSITY_ULTRA: 4,\r\n\r\n\tDEPOSIT_EXHAUST_MULTIPLY: 0.001,\r\n\tDEPOSIT_EXHAUST_POW: 1.2,\r\n\tDEPOSIT_DECAY_TIME: 50000,\r\n\r\n\tTERMINAL_CAPACITY: 300000,\r\n\tTERMINAL_HITS: 3000,\r\n\tTERMINAL_SEND_COST: 0.1,\r\n\tTERMINAL_MIN_SEND: 100,\r\n\tTERMINAL_COOLDOWN: 10,\r\n\r\n\tCONTAINER_HITS: 250000,\r\n\tCONTAINER_CAPACITY: 2000,\r\n\tCONTAINER_DECAY: 5000,\r\n\tCONTAINER_DECAY_TIME: 100,\r\n\tCONTAINER_DECAY_TIME_OWNED: 500,\r\n\r\n\tNUKER_HITS: 1000,\r\n\tNUKER_COOLDOWN: 100000,\r\n\tNUKER_ENERGY_CAPACITY: 300000,\r\n\tNUKER_GHODIUM_CAPACITY: 5000,\r\n\tNUKE_LAND_TIME: 50000,\r\n\tNUKE_RANGE: 10,\r\n\tNUKE_DAMAGE: {\r\n\t\t0: 10000000,\r\n\t\t2: 5000000,\r\n\t},\r\n\r\n\tFACTORY_HITS: 1000,\r\n\tFACTORY_CAPACITY: 50000,\r\n\r\n\tTOMBSTONE_DECAY_PER_PART: 5,\r\n\tTOMBSTONE_DECAY_POWER_CREEP: 500,\r\n\r\n\tRUIN_DECAY: 500,\r\n\tRUIN_DECAY_STRUCTURES: {\r\n\t\tpowerBank: 10,\r\n\t},\r\n\r\n\tPORTAL_DECAY: 30000,\r\n\r\n\tORDER_SELL: \"sell\",\r\n\tORDER_BUY: \"buy\",\r\n\r\n\tMARKET_FEE: 0.05,\r\n\r\n\tMARKET_MAX_ORDERS: 300,\r\n\tMARKET_ORDER_LIFE_TIME: 1000 * 60 * 60 * 24 * 30,\r\n\r\n\tFLAGS_LIMIT: 10000,\r\n\r\n\tSUBSCRIPTION_TOKEN: \"token\",\r\n\tCPU_UNLOCK: \"cpuUnlock\",\r\n\tPIXEL: \"pixel\",\r\n\tACCESS_KEY: \"accessKey\",\r\n\r\n\tPIXEL_CPU_COST: 5000,\r\n\r\n\tRESOURCE_ENERGY: \"energy\",\r\n\tRESOURCE_POWER: \"power\",\r\n\r\n\tRESOURCE_HYDROGEN: \"H\",\r\n\tRESOURCE_OXYGEN: \"O\",\r\n\tRESOURCE_UTRIUM: \"U\",\r\n\tRESOURCE_LEMERGIUM: \"L\",\r\n\tRESOURCE_KEANIUM: \"K\",\r\n\tRESOURCE_ZYNTHIUM: \"Z\",\r\n\tRESOURCE_CATALYST: \"X\",\r\n\tRESOURCE_GHODIUM: \"G\",\r\n\r\n\tRESOURCE_SILICON: \"silicon\",\r\n\tRESOURCE_METAL: \"metal\",\r\n\tRESOURCE_BIOMASS: \"biomass\",\r\n\tRESOURCE_MIST: \"mist\",\r\n\r\n\tRESOURCE_HYDROXIDE: \"OH\",\r\n\tRESOURCE_ZYNTHIUM_KEANITE: \"ZK\",\r\n\tRESOURCE_UTRIUM_LEMERGITE: \"UL\",\r\n\r\n\tRESOURCE_UTRIUM_HYDRIDE: \"UH\",\r\n\tRESOURCE_UTRIUM_OXIDE: \"UO\",\r\n\tRESOURCE_KEANIUM_HYDRIDE: \"KH\",\r\n\tRESOURCE_KEANIUM_OXIDE: \"KO\",\r\n\tRESOURCE_LEMERGIUM_HYDRIDE: \"LH\",\r\n\tRESOURCE_LEMERGIUM_OXIDE: \"LO\",\r\n\tRESOURCE_ZYNTHIUM_HYDRIDE: \"ZH\",\r\n\tRESOURCE_ZYNTHIUM_OXIDE: \"ZO\",\r\n\tRESOURCE_GHODIUM_HYDRIDE: \"GH\",\r\n\tRESOURCE_GHODIUM_OXIDE: \"GO\",\r\n\r\n\tRESOURCE_UTRIUM_ACID: \"UH2O\",\r\n\tRESOURCE_UTRIUM_ALKALIDE: \"UHO2\",\r\n\tRESOURCE_KEANIUM_ACID: \"KH2O\",\r\n\tRESOURCE_KEANIUM_ALKALIDE: \"KHO2\",\r\n\tRESOURCE_LEMERGIUM_ACID: \"LH2O\",\r\n\tRESOURCE_LEMERGIUM_ALKALIDE: \"LHO2\",\r\n\tRESOURCE_ZYNTHIUM_ACID: \"ZH2O\",\r\n\tRESOURCE_ZYNTHIUM_ALKALIDE: \"ZHO2\",\r\n\tRESOURCE_GHODIUM_ACID: \"GH2O\",\r\n\tRESOURCE_GHODIUM_ALKALIDE: \"GHO2\",\r\n\r\n\tRESOURCE_CATALYZED_UTRIUM_ACID: \"XUH2O\",\r\n\tRESOURCE_CATALYZED_UTRIUM_ALKALIDE: \"XUHO2\",\r\n\tRESOURCE_CATALYZED_KEANIUM_ACID: \"XKH2O\",\r\n\tRESOURCE_CATALYZED_KEANIUM_ALKALIDE: \"XKHO2\",\r\n\tRESOURCE_CATALYZED_LEMERGIUM_ACID: \"XLH2O\",\r\n\tRESOURCE_CATALYZED_LEMERGIUM_ALKALIDE: \"XLHO2\",\r\n\tRESOURCE_CATALYZED_ZYNTHIUM_ACID: \"XZH2O\",\r\n\tRESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE: \"XZHO2\",\r\n\tRESOURCE_CATALYZED_GHODIUM_ACID: \"XGH2O\",\r\n\tRESOURCE_CATALYZED_GHODIUM_ALKALIDE: \"XGHO2\",\r\n\r\n\tRESOURCE_OPS: \"ops\",\r\n\r\n\tRESOURCE_UTRIUM_BAR: \"utrium_bar\",\r\n\tRESOURCE_LEMERGIUM_BAR: \"lemergium_bar\",\r\n\tRESOURCE_ZYNTHIUM_BAR: \"zynthium_bar\",\r\n\tRESOURCE_KEANIUM_BAR: \"keanium_bar\",\r\n\tRESOURCE_GHODIUM_MELT: \"ghodium_melt\",\r\n\tRESOURCE_OXIDANT: \"oxidant\",\r\n\tRESOURCE_REDUCTANT: \"reductant\",\r\n\tRESOURCE_PURIFIER: \"purifier\",\r\n\tRESOURCE_BATTERY: \"battery\",\r\n\r\n\tRESOURCE_COMPOSITE: \"composite\",\r\n\tRESOURCE_CRYSTAL: \"crystal\",\r\n\tRESOURCE_LIQUID: \"liquid\",\r\n\r\n\tRESOURCE_WIRE: \"wire\",\r\n\tRESOURCE_SWITCH: \"switch\",\r\n\tRESOURCE_TRANSISTOR: \"transistor\",\r\n\tRESOURCE_MICROCHIP: \"microchip\",\r\n\tRESOURCE_CIRCUIT: \"circuit\",\r\n\tRESOURCE_DEVICE: \"device\",\r\n\r\n\tRESOURCE_CELL: \"cell\",\r\n\tRESOURCE_PHLEGM: \"phlegm\",\r\n\tRESOURCE_TISSUE: \"tissue\",\r\n\tRESOURCE_MUSCLE: \"muscle\",\r\n\tRESOURCE_ORGANOID: \"organoid\",\r\n\tRESOURCE_ORGANISM: \"organism\",\r\n\r\n\tRESOURCE_ALLOY: \"alloy\",\r\n\tRESOURCE_TUBE: \"tube\",\r\n\tRESOURCE_FIXTURES: \"fixtures\",\r\n\tRESOURCE_FRAME: \"frame\",\r\n\tRESOURCE_HYDRAULICS: \"hydraulics\",\r\n\tRESOURCE_MACHINE: \"machine\",\r\n\r\n\tRESOURCE_CONDENSATE: \"condensate\",\r\n\tRESOURCE_CONCENTRATE: \"concentrate\",\r\n\tRESOURCE_EXTRACT: \"extract\",\r\n\tRESOURCE_SPIRIT: \"spirit\",\r\n\tRESOURCE_EMANATION: \"emanation\",\r\n\tRESOURCE_ESSENCE: \"essence\",\r\n\r\n\tREACTIONS: {\r\n\t\tH: {\r\n\t\t\tO: \"OH\",\r\n\t\t\tL: \"LH\",\r\n\t\t\tK: \"KH\",\r\n\t\t\tU: \"UH\",\r\n\t\t\tZ: \"ZH\",\r\n\t\t\tG: \"GH\",\r\n\t\t},\r\n\t\tO: {\r\n\t\t\tH: \"OH\",\r\n\t\t\tL: \"LO\",\r\n\t\t\tK: \"KO\",\r\n\t\t\tU: \"UO\",\r\n\t\t\tZ: \"ZO\",\r\n\t\t\tG: \"GO\",\r\n\t\t},\r\n\t\tZ: {\r\n\t\t\tK: \"ZK\",\r\n\t\t\tH: \"ZH\",\r\n\t\t\tO: \"ZO\",\r\n\t\t},\r\n\t\tL: {\r\n\t\t\tU: \"UL\",\r\n\t\t\tH: \"LH\",\r\n\t\t\tO: \"LO\",\r\n\t\t},\r\n\t\tK: {\r\n\t\t\tZ: \"ZK\",\r\n\t\t\tH: \"KH\",\r\n\t\t\tO: \"KO\",\r\n\t\t},\r\n\t\tG: {\r\n\t\t\tH: \"GH\",\r\n\t\t\tO: \"GO\",\r\n\t\t},\r\n\t\tU: {\r\n\t\t\tL: \"UL\",\r\n\t\t\tH: \"UH\",\r\n\t\t\tO: \"UO\",\r\n\t\t},\r\n\t\tOH: {\r\n\t\t\tUH: \"UH2O\",\r\n\t\t\tUO: \"UHO2\",\r\n\t\t\tZH: \"ZH2O\",\r\n\t\t\tZO: \"ZHO2\",\r\n\t\t\tKH: \"KH2O\",\r\n\t\t\tKO: \"KHO2\",\r\n\t\t\tLH: \"LH2O\",\r\n\t\t\tLO: \"LHO2\",\r\n\t\t\tGH: \"GH2O\",\r\n\t\t\tGO: \"GHO2\",\r\n\t\t},\r\n\t\tX: {\r\n\t\t\tUH2O: \"XUH2O\",\r\n\t\t\tUHO2: \"XUHO2\",\r\n\t\t\tLH2O: \"XLH2O\",\r\n\t\t\tLHO2: \"XLHO2\",\r\n\t\t\tKH2O: \"XKH2O\",\r\n\t\t\tKHO2: \"XKHO2\",\r\n\t\t\tZH2O: \"XZH2O\",\r\n\t\t\tZHO2: \"XZHO2\",\r\n\t\t\tGH2O: \"XGH2O\",\r\n\t\t\tGHO2: \"XGHO2\",\r\n\t\t},\r\n\t\tZK: {\r\n\t\t\tUL: \"G\",\r\n\t\t},\r\n\t\tUL: {\r\n\t\t\tZK: \"G\",\r\n\t\t},\r\n\t\tLH: {\r\n\t\t\tOH: \"LH2O\",\r\n\t\t},\r\n\t\tZH: {\r\n\t\t\tOH: \"ZH2O\",\r\n\t\t},\r\n\t\tGH: {\r\n\t\t\tOH: \"GH2O\",\r\n\t\t},\r\n\t\tKH: {\r\n\t\t\tOH: \"KH2O\",\r\n\t\t},\r\n\t\tUH: {\r\n\t\t\tOH: \"UH2O\",\r\n\t\t},\r\n\t\tLO: {\r\n\t\t\tOH: \"LHO2\",\r\n\t\t},\r\n\t\tZO: {\r\n\t\t\tOH: \"ZHO2\",\r\n\t\t},\r\n\t\tKO: {\r\n\t\t\tOH: \"KHO2\",\r\n\t\t},\r\n\t\tUO: {\r\n\t\t\tOH: \"UHO2\",\r\n\t\t},\r\n\t\tGO: {\r\n\t\t\tOH: \"GHO2\",\r\n\t\t},\r\n\t\tLH2O: {\r\n\t\t\tX: \"XLH2O\",\r\n\t\t},\r\n\t\tKH2O: {\r\n\t\t\tX: \"XKH2O\",\r\n\t\t},\r\n\t\tZH2O: {\r\n\t\t\tX: \"XZH2O\",\r\n\t\t},\r\n\t\tUH2O: {\r\n\t\t\tX: \"XUH2O\",\r\n\t\t},\r\n\t\tGH2O: {\r\n\t\t\tX: \"XGH2O\",\r\n\t\t},\r\n\t\tLHO2: {\r\n\t\t\tX: \"XLHO2\",\r\n\t\t},\r\n\t\tUHO2: {\r\n\t\t\tX: \"XUHO2\",\r\n\t\t},\r\n\t\tKHO2: {\r\n\t\t\tX: \"XKHO2\",\r\n\t\t},\r\n\t\tZHO2: {\r\n\t\t\tX: \"XZHO2\",\r\n\t\t},\r\n\t\tGHO2: {\r\n\t\t\tX: \"XGHO2\",\r\n\t\t},\r\n\t},\r\n\r\n\tBOOSTS: {\r\n\t\twork: {\r\n\t\t\tUO: {\r\n\t\t\t\tharvest: 3,\r\n\t\t\t},\r\n\t\t\tUHO2: {\r\n\t\t\t\tharvest: 5,\r\n\t\t\t},\r\n\t\t\tXUHO2: {\r\n\t\t\t\tharvest: 7,\r\n\t\t\t},\r\n\t\t\tLH: {\r\n\t\t\t\tbuild: 1.5,\r\n\t\t\t\trepair: 1.5,\r\n\t\t\t},\r\n\t\t\tLH2O: {\r\n\t\t\t\tbuild: 1.8,\r\n\t\t\t\trepair: 1.8,\r\n\t\t\t},\r\n\t\t\tXLH2O: {\r\n\t\t\t\tbuild: 2,\r\n\t\t\t\trepair: 2,\r\n\t\t\t},\r\n\t\t\tZH: {\r\n\t\t\t\tdismantle: 2,\r\n\t\t\t},\r\n\t\t\tZH2O: {\r\n\t\t\t\tdismantle: 3,\r\n\t\t\t},\r\n\t\t\tXZH2O: {\r\n\t\t\t\tdismantle: 4,\r\n\t\t\t},\r\n\t\t\tGH: {\r\n\t\t\t\tupgradeController: 1.5,\r\n\t\t\t},\r\n\t\t\tGH2O: {\r\n\t\t\t\tupgradeController: 1.8,\r\n\t\t\t},\r\n\t\t\tXGH2O: {\r\n\t\t\t\tupgradeController: 2,\r\n\t\t\t},\r\n\t\t},\r\n\t\tattack: {\r\n\t\t\tUH: {\r\n\t\t\t\tattack: 2,\r\n\t\t\t},\r\n\t\t\tUH2O: {\r\n\t\t\t\tattack: 3,\r\n\t\t\t},\r\n\t\t\tXUH2O: {\r\n\t\t\t\tattack: 4,\r\n\t\t\t},\r\n\t\t},\r\n\t\tranged_attack: {\r\n\t\t\tKO: {\r\n\t\t\t\trangedAttack: 2,\r\n\t\t\t\trangedMassAttack: 2,\r\n\t\t\t},\r\n\t\t\tKHO2: {\r\n\t\t\t\trangedAttack: 3,\r\n\t\t\t\trangedMassAttack: 3,\r\n\t\t\t},\r\n\t\t\tXKHO2: {\r\n\t\t\t\trangedAttack: 4,\r\n\t\t\t\trangedMassAttack: 4,\r\n\t\t\t},\r\n\t\t},\r\n\t\theal: {\r\n\t\t\tLO: {\r\n\t\t\t\theal: 2,\r\n\t\t\t\trangedHeal: 2,\r\n\t\t\t},\r\n\t\t\tLHO2: {\r\n\t\t\t\theal: 3,\r\n\t\t\t\trangedHeal: 3,\r\n\t\t\t},\r\n\t\t\tXLHO2: {\r\n\t\t\t\theal: 4,\r\n\t\t\t\trangedHeal: 4,\r\n\t\t\t},\r\n\t\t},\r\n\t\tcarry: {\r\n\t\t\tKH: {\r\n\t\t\t\tcapacity: 2,\r\n\t\t\t},\r\n\t\t\tKH2O: {\r\n\t\t\t\tcapacity: 3,\r\n\t\t\t},\r\n\t\t\tXKH2O: {\r\n\t\t\t\tcapacity: 4,\r\n\t\t\t},\r\n\t\t},\r\n\t\tmove: {\r\n\t\t\tZO: {\r\n\t\t\t\tfatigue: 2,\r\n\t\t\t},\r\n\t\t\tZHO2: {\r\n\t\t\t\tfatigue: 3,\r\n\t\t\t},\r\n\t\t\tXZHO2: {\r\n\t\t\t\tfatigue: 4,\r\n\t\t\t},\r\n\t\t},\r\n\t\ttough: {\r\n\t\t\tGO: {\r\n\t\t\t\tdamage: 0.7,\r\n\t\t\t},\r\n\t\t\tGHO2: {\r\n\t\t\t\tdamage: 0.5,\r\n\t\t\t},\r\n\t\t\tXGHO2: {\r\n\t\t\t\tdamage: 0.3,\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\r\n\tREACTION_TIME: {\r\n\t\tOH: 20,\r\n\t\tZK: 5,\r\n\t\tUL: 5,\r\n\t\tG: 5,\r\n\t\tUH: 10,\r\n\t\tUH2O: 5,\r\n\t\tXUH2O: 60,\r\n\t\tUO: 10,\r\n\t\tUHO2: 5,\r\n\t\tXUHO2: 60,\r\n\t\tKH: 10,\r\n\t\tKH2O: 5,\r\n\t\tXKH2O: 60,\r\n\t\tKO: 10,\r\n\t\tKHO2: 5,\r\n\t\tXKHO2: 60,\r\n\t\tLH: 15,\r\n\t\tLH2O: 10,\r\n\t\tXLH2O: 65,\r\n\t\tLO: 10,\r\n\t\tLHO2: 5,\r\n\t\tXLHO2: 60,\r\n\t\tZH: 20,\r\n\t\tZH2O: 40,\r\n\t\tXZH2O: 160,\r\n\t\tZO: 10,\r\n\t\tZHO2: 5,\r\n\t\tXZHO2: 60,\r\n\t\tGH: 10,\r\n\t\tGH2O: 15,\r\n\t\tXGH2O: 80,\r\n\t\tGO: 10,\r\n\t\tGHO2: 30,\r\n\t\tXGHO2: 150,\r\n\t},\r\n\r\n\tPORTAL_UNSTABLE: 10 * 24 * 3600 * 1000,\r\n\tPORTAL_MIN_TIMEOUT: 12 * 24 * 3600 * 1000,\r\n\tPORTAL_MAX_TIMEOUT: 22 * 24 * 3600 * 1000,\r\n\r\n\tPOWER_BANK_RESPAWN_TIME: 50000,\r\n\r\n\tINVADERS_ENERGY_GOAL: 100000,\r\n\r\n\tSYSTEM_USERNAME: \"Screeps\",\r\n\r\n\t// SIGN_NOVICE_AREA and SIGN_RESPAWN_AREA constants are deprecated, please use SIGN_PLANNED_AREA instead\r\n\tSIGN_NOVICE_AREA: \"A new Novice or Respawn Area is being planned somewhere in this sector. Please make sure all important rooms are reserved.\",\r\n\tSIGN_RESPAWN_AREA: \"A new Novice or Respawn Area is being planned somewhere in this sector. Please make sure all important rooms are reserved.\",\r\n\tSIGN_PLANNED_AREA: \"A new Novice or Respawn Area is being planned somewhere in this sector. Please make sure all important rooms are reserved.\",\r\n\r\n\tEVENT_ATTACK: 1,\r\n\tEVENT_OBJECT_DESTROYED: 2,\r\n\tEVENT_ATTACK_CONTROLLER: 3,\r\n\tEVENT_BUILD: 4,\r\n\tEVENT_HARVEST: 5,\r\n\tEVENT_HEAL: 6,\r\n\tEVENT_REPAIR: 7,\r\n\tEVENT_RESERVE_CONTROLLER: 8,\r\n\tEVENT_UPGRADE_CONTROLLER: 9,\r\n\tEVENT_EXIT: 10,\r\n\tEVENT_POWER: 11,\r\n\tEVENT_TRANSFER: 12,\r\n\r\n\tEVENT_ATTACK_TYPE_MELEE: 1,\r\n\tEVENT_ATTACK_TYPE_RANGED: 2,\r\n\tEVENT_ATTACK_TYPE_RANGED_MASS: 3,\r\n\tEVENT_ATTACK_TYPE_DISMANTLE: 4,\r\n\tEVENT_ATTACK_TYPE_HIT_BACK: 5,\r\n\tEVENT_ATTACK_TYPE_NUKE: 6,\r\n\r\n\tEVENT_HEAL_TYPE_MELEE: 1,\r\n\tEVENT_HEAL_TYPE_RANGED: 2,\r\n\r\n\tPOWER_LEVEL_MULTIPLY: 1000,\r\n\tPOWER_LEVEL_POW: 2,\r\n\tPOWER_CREEP_SPAWN_COOLDOWN: 8 * 3600 * 1000,\r\n\tPOWER_CREEP_DELETE_COOLDOWN: 24 * 3600 * 1000,\r\n\tPOWER_CREEP_MAX_LEVEL: 25,\r\n\tPOWER_CREEP_LIFE_TIME: 5000,\r\n\r\n\tPOWER_CLASS: {\r\n\t\tOPERATOR: \"operator\",\r\n\t},\r\n\r\n\tPWR_GENERATE_OPS: 1,\r\n\tPWR_OPERATE_SPAWN: 2,\r\n\tPWR_OPERATE_TOWER: 3,\r\n\tPWR_OPERATE_STORAGE: 4,\r\n\tPWR_OPERATE_LAB: 5,\r\n\tPWR_OPERATE_EXTENSION: 6,\r\n\tPWR_OPERATE_OBSERVER: 7,\r\n\tPWR_OPERATE_TERMINAL: 8,\r\n\tPWR_DISRUPT_SPAWN: 9,\r\n\tPWR_DISRUPT_TOWER: 10,\r\n\tPWR_DISRUPT_SOURCE: 11,\r\n\tPWR_SHIELD: 12,\r\n\tPWR_REGEN_SOURCE: 13,\r\n\tPWR_REGEN_MINERAL: 14,\r\n\tPWR_DISRUPT_TERMINAL: 15,\r\n\tPWR_OPERATE_POWER: 16,\r\n\tPWR_FORTIFY: 17,\r\n\tPWR_OPERATE_CONTROLLER: 18,\r\n\tPWR_OPERATE_FACTORY: 19,\r\n\r\n\tEFFECT_INVULNERABILITY: 1001,\r\n\tEFFECT_COLLAPSE_TIMER: 1002,\r\n\r\n\tINVADER_CORE_HITS: 100000,\r\n\tINVADER_CORE_CREEP_SPAWN_TIME: {\r\n\t\t0: 0,\r\n\t\t1: 0,\r\n\t\t2: 6,\r\n\t\t3: 3,\r\n\t\t4: 2,\r\n\t\t5: 1,\r\n\t},\r\n\tINVADER_CORE_EXPAND_TIME: { 1: 4000, 2: 3500, 3: 3000, 4: 2500, 5: 2000 },\r\n\tINVADER_CORE_CONTROLLER_POWER: 2,\r\n\tINVADER_CORE_CONTROLLER_DOWNGRADE: 5000,\r\n\tSTRONGHOLD_RAMPART_HITS: { 0: 0, 1: 100000, 2: 200000, 3: 500000, 4: 1000000, 5: 2000000 },\r\n\tSTRONGHOLD_DECAY_TICKS: 75000,\r\n};\r\n\n\n//# sourceURL=webpack:///./src/testing/constants.js?");

/***/ })

/******/ })));