(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// app.js\r\n\r\nmodule.exports = function () {\r\n\tif (!Memory.sources) {\r\n\t\tMemory.sources = {};\r\n\t}\r\n\r\n\tif (!Memory.counts) {\r\n\t\tMemory.counts = {};\r\n\t}\r\n\r\n\tconst Move = __webpack_require__(/*! ./modules/move.js */ \"./src/modules/move.js\");\r\n\tthis.move = new Move();\r\n\r\n\tconst CreepRequisitioner = __webpack_require__(/*! ./modules/creepRequisitioner.js */ \"./src/modules/creepRequisitioner.js\");\r\n\tthis.creepRequisitioner = new CreepRequisitioner();\r\n\r\n\tconst Resource = __webpack_require__(/*! ./modules/resource.js */ \"./src/modules/resource.js\");\r\n\tthis.resource = new Resource();\r\n\r\n\t// run function will activate every loop\r\n\tthis.run = () => {\r\n\t\tthis.runRooms();\r\n\r\n\t\tthis.runCreeps();\r\n\t};\r\n\r\n\tthis.runRooms = () => {\r\n\t\tfor (const i in Game.rooms) {\r\n\t\t\tlet room = Game.rooms[i];\r\n\r\n\t\t\tif (room.controller.my) {\r\n\t\t\t\t//console.log(`runRooms room: ${room.name}`);\r\n\r\n\t\t\t\tif (room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\tlet spawnQueueCopy = [];\r\n\r\n\t\t\t\t\troom.memory.spawnQueue.forEach((id) => {\r\n\t\t\t\t\t\tif (Memory.spawnQueueItems[id]) {\r\n\t\t\t\t\t\t\tspawnQueueCopy.push(id);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\troom.memory.spawnQueue = spawnQueueCopy;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet sources = room.find(FIND_SOURCES);\r\n\t\t\t\t//console.log('after finding sources');\r\n\t\t\t\tif (!sources) {\r\n\t\t\t\t\tconsole.log(`runRooms: no sources found! room: ${room.name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//console.log(`runRooms: no. sources found: ${sources.length}`);\r\n\t\t\t\t\tfor (let j = 0; j < sources.length; j++) {\r\n\t\t\t\t\t\tlet source = sources[j];\r\n\t\t\t\t\t\t//console.log(`runRooms | source: ${source.id}`);\r\n\r\n\t\t\t\t\t\tif (!Memory.sources[source.id]) {\r\n\t\t\t\t\t\t\tconst accessPos = this.getAccessiblePositions(source.pos);\r\n\t\t\t\t\t\t\tMemory.sources[source.id] = {\r\n\t\t\t\t\t\t\t\tnoOfAccessPos: accessPos.length,\r\n\t\t\t\t\t\t\t\tcreepsAssigned: 0,\r\n\t\t\t\t\t\t\t\tcreepsPending: 0,\r\n\t\t\t\t\t\t\t\tcreepIds: {},\r\n\t\t\t\t\t\t\t\tpendingCreepIds: {},\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar sourceMemory = Memory.sources[source.id];\r\n\r\n\t\t\t\t\t\tif (!sourceMemory.creepIds) {\r\n\t\t\t\t\t\t\tsourceMemory.creepIds = {};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// clean up dead creeps from source memory\r\n\t\t\t\t\t\tfor (const name in sourceMemory.creepIds) {\r\n\t\t\t\t\t\t\tvar creepname = sourceMemory.creepIds[name];\r\n\t\t\t\t\t\t\tlet creep = Game.creeps[creepname];\r\n\r\n\t\t\t\t\t\t\tif (!creep) {\r\n\t\t\t\t\t\t\t\tdelete sourceMemory.creepIds[name];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar noCreepIds = Object.keys(sourceMemory.creepIds).length;\r\n\r\n\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// check for any defunct pending creeps\r\n\t\t\t\t\t\t\tfor (const id in sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\tif (!Memory.spawnQueueItems[sourceMemory.pendingCreepIds[id]]) {\r\n\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[id];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar creepsPending = Object.keys(sourceMemory.pendingCreepIds),\r\n\t\t\t\t\t\t\tnoCreepsRequired = sourceMemory.noOfAccessPos - noCreepIds;\r\n\r\n\t\t\t\t\t\t// console.log(\r\n\t\t\t\t\t\t// \t`source run. noCreepsRequired ${noCreepsRequired} | noOfAccessPos ${sourceMemory.noOfAccessPos} | noCreepIds ${noCreepIds} | creepsPending ${creepsPending}`\r\n\t\t\t\t\t\t// );\r\n\r\n\t\t\t\t\t\tfor (var q = 0; q < noCreepsRequired; q++) {\r\n\t\t\t\t\t\t\tlet creep = this.creepRequisitioner.getIdleCreep(source.room, CREEP_TYPES.UTILITY, {\r\n\t\t\t\t\t\t\t\trole: CREEP_ROLES.HARVESTER,\r\n\t\t\t\t\t\t\t\tsourceId: source.id,\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tif (creep) {\r\n\t\t\t\t\t\t\t\tsourceMemory.creepIds[creep.name] = creep.name;\r\n\t\t\t\t\t\t\t\tnoCreepIds++;\r\n\t\t\t\t\t\t\t\tlet spawnQueueItemId = creepsPending.shift(); //get first pending id\r\n\t\t\t\t\t\t\t\tif (Memory.spawnQueueItems[spawnQueueItemId]) {\r\n\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t\tdelete Memory.spawnQueueItems[spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet noCreepsPending = creepsPending.length;\r\n\r\n\t\t\t\t\t\tif (sourceMemory.noOfAccessPos > noCreepsPending + noCreepIds) {\r\n\t\t\t\t\t\t\t// console.log(\r\n\t\t\t\t\t\t\t// \t`sourceMemory.noOfAccessPos:${sourceMemory.noOfAccessPos} > sourceMemory.creepsPending:${sourceMemory.creepsPending}`\r\n\t\t\t\t\t\t\t// );\r\n\r\n\t\t\t\t\t\t\twhile (noCreepsPending + noCreepIds < sourceMemory.noOfAccessPos) {\r\n\t\t\t\t\t\t\t\tlet spawnQueueItem = this.creepRequisitioner.addCreepToRoomSpawnQueue(source.room, CREEP_TYPES.UTILITY, {\r\n\t\t\t\t\t\t\t\t\trole: CREEP_ROLES.HARVESTER,\r\n\t\t\t\t\t\t\t\t\tsourceId: source.id,\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// if response exists but isn't spawning resonse (1) must have found idle creep\r\n\t\t\t\t\t\t\t\tif (spawnQueueItem) {\r\n\t\t\t\t\t\t\t\t\t//console.log(`spawnQueueItem: ${JSON.stringify(spawnQueueItem)}`);\r\n\t\t\t\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds[spawnQueueItem.id] = spawnQueueItem.id;\r\n\t\t\t\t\t\t\t\t\tnoCreepsPending++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tconsole.log(`No spawn queue Item found!`);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tMemory.sources[source.id] = sourceMemory;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet spawns = room.find(FIND_MY_STRUCTURES, {\r\n\t\t\t\t\tfilter: { structureType: STRUCTURE_SPAWN },\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (!spawns) {\r\n\t\t\t\t\tconsole.log(`runRooms: No spawns found! room: ${room.name}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\t\tconsole.log('spawn queue logic');\r\n\t\t\t\t\t\tfor (let i = 0; i < spawns.length; i++) {\r\n\t\t\t\t\t\t\tlet spawn = spawns[i];\r\n\r\n\t\t\t\t\t\t\tconsole.log(`found spawn ${spawn.id}`);\r\n\r\n\t\t\t\t\t\t\tif (!spawn.memory.creepToSpawn && room.memory.spawnQueue && room.memory.spawnQueue.length) {\r\n\t\t\t\t\t\t\t\tconsole.log('adding creepToSpawn from spawn Queue');\r\n\t\t\t\t\t\t\t\tspawn.memory.creepToSpawn = room.memory.spawnQueue.shift();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (spawn.memory.creepToSpawn) {\r\n\t\t\t\t\t\t\t\tconsole.log(`spawn memory creepToSpawn ${spawn.memory.creepToSpawn}`);\r\n\t\t\t\t\t\t\t\tlet spawnQueueItem = Memory.spawnQueueItems[spawn.memory.creepToSpawn];\r\n\r\n\t\t\t\t\t\t\t\tif (spawnQueueItem) {\r\n\t\t\t\t\t\t\t\t\tconsole.log(`processing creep to spawn: ${JSON.stringify(spawn.memory.creepToSpawn)}`);\r\n\t\t\t\t\t\t\t\t\tconst creepBodyResponse = this.getCreepBody(spawnQueueItem.type, spawn.room.energyCapacityAvailable);\r\n\t\t\t\t\t\t\t\t\t// console.log('creep body type result:');\r\n\t\t\t\t\t\t\t\t\t// console.log(JSON.stringify(creepBodyResponse));\r\n\r\n\t\t\t\t\t\t\t\t\tconst spawnCapacityUsed = spawn.store.getUsedCapacity(RESOURCE_ENERGY);\r\n\t\t\t\t\t\t\t\t\tif (creepBodyResponse.cost > spawnCapacityUsed) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`not enough energy to spawnCreep | cost:${creepBodyResponse.cost} | energy:${spawnCapacityUsed}`);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (!this.resource.getStructureResourceOrderId(spawn, RESOURCE_ENERGY)) {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.resource.createResourceOrder(\r\n\t\t\t\t\t\t\t\t\t\t\t\troom,\r\n\t\t\t\t\t\t\t\t\t\t\t\tspawn.id,\r\n\t\t\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\t\t\tcreepBodyResponse.cost - spawnCapacityUsed\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tspawnQueueItem.memory.type = spawnQueueItem.type;\r\n\t\t\t\t\t\t\t\t\t\tvar spawnCreepResult = spawn.spawnCreep(creepBodyResponse.creepBody, this.getNextCreepName(), {\r\n\t\t\t\t\t\t\t\t\t\t\tmemory: spawnQueueItem.memory,\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`spawnCreepResult: ${spawnCreepResult}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// doesn't exist any more to delete\r\n\t\t\t\t\t\t\t\t\tconsole.log('Did not find creep to spawn');\r\n\t\t\t\t\t\t\t\t\tdelete spawn.memory.creepToSpawn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.runCreeps = () => {\r\n\t\t//console.log(`No. of creeps: ${Object.keys(Game.creeps).length}`);\r\n\r\n\t\tfor (const name in Game.creeps) {\r\n\t\t\tlet creep = Game.creeps[name];\r\n\t\t\tif (!creep.memory.role) {\r\n\t\t\t\t//do somehting to reassign creep\r\n\t\t\t\tconsole.log('No creep role found in memory adding to idle pool');\r\n\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t}\r\n\r\n\t\t\tif (!creep.memory.type || creep.memory.type === 'unknown') {\r\n\t\t\t\tcreep.memory.type = CREEP_TYPES.UTILITY;\r\n\t\t\t}\r\n\t\t\tswitch (creep.memory.role) {\r\n\t\t\t\tcase 'idle':\r\n\t\t\t\t\tif (!Memory.idleCreeps[creep.name]) {\r\n\t\t\t\t\t\tconsole.log('No creep name found idle creep memory adding to idle pool');\r\n\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcreep.moveTo(0, 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase CREEP_ROLES.HARVESTER:\r\n\t\t\t\t\tif (!creep.memory.currentAction) {\r\n\t\t\t\t\t\tcreep.store.getFreeCapacity(RESOURCE_ENERGY) < creep.store.getCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t? (creep.memory.currentAction = 'goToSource')\r\n\t\t\t\t\t\t\t: (creep.memory.currentAction = 'goToDestination');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch (creep.memory.currentAction) {\r\n\t\t\t\t\t\tcase 'goToSource':\r\n\t\t\t\t\t\t\tlet source = Game.getObjectById(creep.memory.sourceId);\r\n\r\n\t\t\t\t\t\t\tif (!source) {\r\n\t\t\t\t\t\t\t\tconsole.log(`No source found belonging to id ${creep.memory.sourceId}!`);\r\n\t\t\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// check source\r\n\t\t\t\t\t\t\t\tlet sourceMemory = Memory.sources[source.id];\r\n\t\t\t\t\t\t\t\tif (!sourceMemory.creepIds[creep.name]) {\r\n\t\t\t\t\t\t\t\t\tif (Object.keys(sourceMemory.creepIds).length < sourceMemory.noOfAccessPos) {\r\n\t\t\t\t\t\t\t\t\t\tsourceMemory.creepIds[creep.name] = creep.name;\r\n\t\t\t\t\t\t\t\t\t\tif (!sourceMemory.pendingCreepIds) {\r\n\t\t\t\t\t\t\t\t\t\t\tsourceMemory.pendingCreepIds = {};\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (creep.memory.spawnQueueItemId) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (sourceMemory.pendingCreepIds[creep.memory.spawnQueueItemId]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdelete sourceMemory.pendingCreepIds[creep.memory.spawnQueueItemId];\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tdelete creep.memory.spawnQueueItemId;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tthis.creepRequisitioner.addCreepToIdlePool(creep.room, creep);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tMemory.sources[source.id] = sourceMemory;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcreep.moveTo(source.pos);\r\n\t\t\t\t\t\t\tif (creep.pos.isNearTo(source.pos)) {\r\n\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'harvest';\r\n\t\t\t\t\t\t\t\tcreep.harvest(Game.getObjectById(creep.memory.sourceId));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'harvest':\r\n\t\t\t\t\t\t\tif (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\r\n\t\t\t\t\t\t\t\tcreep.harvest(Game.getObjectById(creep.memory.sourceId));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (!creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\t\tthis.resource.findNextResourceOrderToFulfill(\r\n\t\t\t\t\t\t\t\t\t\tcreep.room,\r\n\t\t\t\t\t\t\t\t\t\tcreep,\r\n\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\tcreep.store.getUsedCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToDestination';\r\n\t\t\t\t\t\t\t\tlet destination = this.resource.getResourceOrderItemDestination(creep.memory.resourceOrderItemId);\r\n\t\t\t\t\t\t\t\tcreep.moveTo(destination.pos);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'goToDestination':\r\n\t\t\t\t\t\t\tif (!creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\tif (creep.store.getFreeCapacity(RESOURCE_ENERGY) !== 0) {\r\n\t\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToSource';\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthis.resource.findNextResourceOrderToFulfill(\r\n\t\t\t\t\t\t\t\t\t\tcreep.room,\r\n\t\t\t\t\t\t\t\t\t\tcreep,\r\n\t\t\t\t\t\t\t\t\t\tRESOURCE_ENERGY,\r\n\t\t\t\t\t\t\t\t\t\tcreep.store.getUsedCapacity(RESOURCE_ENERGY)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (creep.memory.resourceOrderItemId) {\r\n\t\t\t\t\t\t\t\tlet destination = this.resource.getResourceOrderItemDestination(creep.memory.resourceOrderItemId);\r\n\t\t\t\t\t\t\t\tcreep.moveTo(destination.pos);\r\n\t\t\t\t\t\t\t\tlet isNear = creep.pos.isNearTo(destination.pos);\r\n\r\n\t\t\t\t\t\t\t\tif (isNear) {\r\n\t\t\t\t\t\t\t\t\tif (destination.structureType === STRUCTURE_CONTROLLER) {\r\n\t\t\t\t\t\t\t\t\t\tlet controller = destination;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (controller.progress >= controller.progressTotal) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet upgradeResult = creep.upgradeController(controller);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tswitch (upgradeResult) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcase OK:\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(`controller upgrade scheduled successfully in room ${creep.room.name}`);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet transferResult = this.resource.fulfillResourceOrderItem(creep);\r\n\r\n\t\t\t\t\t\t\t\t\tif (transferResult !== OK) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(`transferResult: ${transferResult}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcreep.memory.currentAction = 'goToSource';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//clean up creep memory\r\n\t\tfor (const name in Memory.creeps) {\r\n\t\t\tif (!Game.creeps[name]) {\r\n\t\t\t\tdelete Memory.creeps[name];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getAccessiblePositions = (pos) => {\r\n\t\t//console.log('Start App.getAccessiblePositions');\r\n\t\t//test\r\n\t\tif (!pos) {\r\n\t\t\tconsole.log('getAccessiblePositions invalid parameter');\r\n\t\t}\r\n\r\n\t\tvar room = Game.rooms[pos.roomName];\r\n\t\tvar terrain = room.getTerrain();\r\n\t\tvar accessiblePositions = [];\r\n\r\n\t\tlet surroundingPositions = [\r\n\t\t\t{ x: pos.x - 1, y: pos.y - 1 },\r\n\t\t\t{ x: pos.x - 1, y: pos.y },\r\n\t\t\t{ x: pos.x - 1, y: pos.y + 1 },\r\n\t\t\t{ x: pos.x, y: pos.y - 1 },\r\n\t\t\t//{ x: pos.x, y: pos.y },\r\n\t\t\t{ x: pos.x, y: pos.y + 1 },\r\n\t\t\t{ x: pos.x + 1, y: pos.y - 1 },\r\n\t\t\t{ x: pos.x + 1, y: pos.y },\r\n\t\t\t{ x: pos.x + 1, y: pos.y + 1 },\r\n\t\t];\r\n\r\n\t\tsurroundingPositions.forEach((pos) => {\r\n\t\t\tconst terrainGet = terrain.get(pos.x, pos.y);\r\n\t\t\tconst isAccessible = pos.x >= 0 && pos.x <= 49 && pos.y >= 0 && pos.y <= 49 && terrainGet === 0;\r\n\t\t\t//console.log(`terrain.get: ${terrainGet} for ${pos.x},${pos.y} isAccessible: ${isAccessible}`);\r\n\r\n\t\t\tif (isAccessible) {\r\n\t\t\t\taccessiblePositions.push(pos);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn accessiblePositions;\r\n\t};\r\n\r\n\tthis.getNextCreepName = () => {\r\n\t\t//console.log('Start App.getNextCreepName');\r\n\r\n\t\tif (!Memory.settings) {\r\n\t\t\tMemory.settings = {\r\n\t\t\t\tcreepCount: 0,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tMemory.settings.creepCount++;\r\n\r\n\t\treturn `Creep${Memory.settings.creepCount}`;\r\n\t};\r\n\r\n\tthis.getCreepBody = (creepType, availableEnergy) => {\r\n\t\t//console.log('Start App.getCreepBody');\r\n\t\tconst creepTemplate = CREEP_BODIES[creepType];\r\n\t\t//console.log(`creep template: ${JSON.stringify(creepTemplate)}`);\r\n\r\n\t\tlet currentCost = 0,\r\n\t\t\tcreepBodyResponse = {\r\n\t\t\t\tcreepBody: [],\r\n\t\t\t\tbodyCounts: {\r\n\t\t\t\t\tmove: 0,\r\n\t\t\t\t\twork: 0,\r\n\t\t\t\t\tcarry: 0,\r\n\t\t\t\t\tattack: 0,\r\n\t\t\t\t\tranged_attack: 0,\r\n\t\t\t\t\ttough: 0,\r\n\t\t\t\t\theal: 0,\r\n\t\t\t\t\tclaim: 0,\r\n\t\t\t\t\ttotal: 0,\r\n\t\t\t\t},\r\n\t\t\t\tbodyTotal: 0,\r\n\t\t\t\tcost: 0,\r\n\t\t\t};\r\n\r\n\t\tlet ratioCost = 0;\r\n\r\n\t\tfor (const bodyPart in creepTemplate) {\r\n\t\t\t// use spawn max energy to calculate max creep body possible\r\n\t\t\tconst creepTemplateItem = creepTemplate[bodyPart];\r\n\r\n\t\t\t//console.log(`creepTemplateItem: ${JSON.stringify(creepTemplateItem)}`);\r\n\r\n\t\t\tif (creepTemplateItem.value > 0) {\r\n\t\t\t\tlet bodyCost = BODYPART_COST[bodyPart];\r\n\t\t\t\t// e.g. available energy * 0.3\r\n\t\t\t\t//bodyToSpend = availableEnergy * creepTemplateItem.value,\r\n\t\t\t\t// Round down to nearest whole no. as you don't get half a body part.\r\n\t\t\t\t//bodyNo = Math.floor(bodyToSpend / bodyCost);\r\n\t\t\t\t//console.log(`availableEnergy: ${availableEnergy}`);\r\n\t\t\t\t//console.log(`bodyPart: ${bodyPart} | bodyCost: ${bodyCost} | bodyToSpend: ${bodyToSpend} | bodyNo:${bodyNo}`);\r\n\t\t\t\t// if (bodyNo === 0) {\r\n\t\t\t\t// \t// no enough to add body part so return invalid target error\r\n\t\t\t\t// \treturn ERR_INVALID_TARGET;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\t// if (creepTemplateItem.max && bodyNo > creepTemplateItem.max) {\r\n\t\t\t\t// \tbodyNo = creepTemplateItem.max;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tratioCost += bodyCost * creepTemplateItem.value;\r\n\r\n\t\t\t\t// for (let i = 0; i < creepTemplateItem.value; i++) {\r\n\t\t\t\t// \t// creepBodyResponse.creepBody.push(bodyPart);\r\n\t\t\t\t// \t// creepBodyResponse.bodyCounts[bodyPart]++;\r\n\t\t\t\t// \t// creepBodyResponse.bodyTotal++;\r\n\t\t\t\t// \t// creepBodyResponse.cost += bodyCost;\r\n\t\t\t\t// }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet ratio = Math.floor(availableEnergy / ratioCost);\r\n\r\n\t\tif (ratio === 0) {\r\n\t\t\tconsole.log('not enough energy capacity to generate creep template');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (const bodyPart in creepTemplate) {\r\n\t\t\tconst creepTemplateItem = creepTemplate[bodyPart];\r\n\r\n\t\t\tif (creepTemplateItem.value > 0) {\r\n\t\t\t\tcreepBodyResponse.bodyCounts[bodyPart] += ratio;\r\n\t\t\t\tcreepBodyResponse.bodyTotal += ratio;\r\n\r\n\t\t\t\tcreepBodyResponse.cost += BODYPART_COST[bodyPart] * ratio;\r\n\r\n\t\t\t\tfor (var i = 0; i < ratio; i++) {\r\n\t\t\t\t\tcreepBodyResponse.creepBody.push(bodyPart);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn creepBodyResponse;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/common/constants.js":
/*!*********************************!*\
  !*** ./src/common/constants.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** constants.js **/\r\n\r\nglobal.COORDINATES_MAX_SIZE = 49;\r\n\r\nglobal.CREEP_ROLES = {\r\n\tHARVESTER: \"harvester\",\r\n\tSCOUT: \"scout\",\r\n};\r\n\r\nglobal.CREEP_TYPES = {\r\n\tUTILITY: \"utility\",\r\n\tMINER: \"miner\",\r\n\tHAULER: \"hauler\",\r\n\tCLAIMER: \"claimer\",\r\n\tMELEE: \"melee\",\r\n\tRANGED: \"ranged\",\r\n\tTANK: \"tank\",\r\n\tHEALER: \"healer\",\r\n};\r\n\r\nglobal.CREEP_BODIES = {\r\n\t[CREEP_TYPES.UTILITY]: {\r\n\t\tmove: { value: 2 },\r\n\t\twork: { value: 1 },\r\n\t\tcarry: { value: 1 },\r\n\t\tattack: { value: 0 },\r\n\t\tranged_attack: { value: 0 },\r\n\t\ttough: { value: 0 },\r\n\t\theal: { value: 0 },\r\n\t\tclaim: { value: 0 },\r\n\t},\r\n\t[CREEP_TYPES.MINER]: {\r\n\t\tMOVE: 0.1,\r\n\t\tWORK: { value: 0.9, max: 5 },\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0,\r\n\t},\r\n\t[CREEP_TYPES.HAULER]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0.5,\r\n\t\tATTACK: 0,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0,\r\n\t},\r\n\t[CREEP_TYPES.CLAIMER]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0.5,\r\n\t},\r\n\t[CREEP_TYPES.MELEE]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0.5,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0,\r\n\t},\r\n\t[CREEP_TYPES.RANGED]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0,\r\n\t\tRANGED_ATTACK: 0.5,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0,\r\n\t},\r\n\t[CREEP_TYPES.TANK]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0.25,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0.25,\r\n\t\tHEAL: 0,\r\n\t\tCLAIM: 0,\r\n\t},\r\n\t[CREEP_TYPES.HEALER]: {\r\n\t\tMOVE: 0.5,\r\n\t\tWORK: 0,\r\n\t\tCARRY: 0,\r\n\t\tATTACK: 0,\r\n\t\tRANGED_ATTACK: 0,\r\n\t\tTOUGH: 0,\r\n\t\tHEAL: 0.5,\r\n\t\tCLAIM: 0,\r\n\t},\r\n};\r\n\r\nglobal.RESOURCE_ORDER_STRUCTURE_PRIORITY = [\r\n\tSTRUCTURE_SPAWN,\r\n\tSTRUCTURE_STORAGE,\r\n\tSTRUCTURE_EXTENSION,\r\n\t//STRUCTURE_ROAD,\r\n\t//STRUCTURE_WALL,\r\n\t//STRUCTURE_RAMPART,\r\n\tSTRUCTURE_TOWER,\r\n\r\n\t//STRUCTURE_CONTAINER,\r\n\t//STRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n\t//STRUCTURE_PORTAL,\r\n\t//STRUCTURE_CONTROLLER,\r\n\t//STRUCTURE_LINK,\r\n\r\n\t//STRUCTURE_OBSERVER,\r\n\t//STRUCTURE_POWER_BANK: \"powerBank\",\r\n\t//STRUCTURE_POWER_SPAWN: \"powerSpawn\",\r\n\t//STRUCTURE_EXTRACTOR: \"extractor\",\r\n\t//STRUCTURE_LAB: \"lab\",\r\n\t//STRUCTURE_TERMINAL: \"terminal\",\r\n\r\n\t//STRUCTURE_NUKER: \"nuker\",\r\n\t//STRUCTURE_FACTORY: \"factory\",\r\n\t//STRUCTURE_INVADER_CORE: \"invaderCore\",\r\n];\r\n\n\n//# sourceURL=webpack:///./src/common/constants.js?");

/***/ }),

/***/ "./src/common/helper.js":
/*!******************************!*\
  !*** ./src/common/helper.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tthis.objExists = function (obj) {\r\n\t\treturn typeof obj !== \"undefined\" && obj !== null;\r\n\t};\r\n\r\n\tthis.getCurrentDateTimeAsString = function () {\r\n\t\tvar date = new Date();\r\n\t\tvar sp = \"-\";\r\n\t\tvar dd = date.getDate();\r\n\t\tvar mm = date.getMonth() + 1; //As January is 0.\r\n\t\tvar yyyy = date.getFullYear();\r\n\r\n\t\tif (dd < 10) dd = \"0\" + dd;\r\n\t\tif (mm < 10) mm = \"0\" + mm;\r\n\t\treturn mm + sp + dd + sp + yyyy;\r\n\t};\r\n\r\n\tthis.getFuncName = function (fn) {\r\n\t\tvar f = typeof fn == \"function\";\r\n\t\tvar s = f && ((fn.name && [\"\", fn.name]) || fn.toString().match(/function ([^\\(]+)/));\r\n\t\treturn (!f && \"not a function\") || (s && s[1]) || \"anonymous\";\r\n\t};\r\n\r\n\tthis.getPosName = (x, y) => {\r\n\t\treturn `${x}-${y}`;\r\n\t};\r\n\r\n\tthis.isPosNearEdge = (x, y) => {\r\n\t\treturn x !== 0 && x !== COORDINATES_MAX_SIZE && y !== 0 && y !== COORDINATES_MAX_SIZE;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/common/helper.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.loop = function() {\r\n\t__webpack_require__(/*! ./common/constants.js */ \"./src/common/constants.js\");\r\n\r\n\tthis.attachLogger = obj => {\r\n\t\tlet name, fn;\r\n\t\tfor (name in obj) {\r\n\t\t\tfn = obj[name];\r\n\t\t\tif (typeof fn === \"function\") {\r\n\t\t\t\tobj[name] = (function(name, fn) {\r\n\t\t\t\t\tvar args = arguments;\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t(function(name, fn) {\r\n\t\t\t\t\t\t\tconsole.log(\"calling \" + name);\r\n\t\t\t\t\t\t}.apply(this, args));\r\n\t\t\t\t\t\treturn fn.apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t})(name, fn);\r\n\t\t\t} else if (typeof fn === \"object\") {\r\n\t\t\t\tthis.attachLogger(fn, true);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconsole.settings = { debug: true };\r\n\r\n\tconst App = __webpack_require__(/*! ./app.js */ \"./src/app.js\");\r\n\tlet app = new App();\r\n\r\n\tconst RoomSurveyor = __webpack_require__(/*! ./modules/roomSurveyor */ \"./src/modules/roomSurveyor.js\");\r\n\tlet roomSurveyor = new RoomSurveyor(Memory, Game);\r\n\r\n\tif (console.settings.debug) {\r\n\t\tconsole._log = console.log;\r\n\t\tconsole.log = message => {\r\n\t\t\tif (console.settings.debug) {\r\n\t\t\t\tconsole._log(message);\r\n\t\t\t}\r\n\t\t};\r\n\t\t//this.attachLogger(app);\r\n\t\t//this.attachLogger(roomSurveyor);\r\n\t}\r\n\r\n\tconsole.debug = func => {\r\n\t\tfunc();\r\n\t};\r\n\r\n\tconsole.log(\"loop start\");\r\n\r\n\ttry {\r\n\t\t//app.run();\r\n\t\tfor (var roomName in Game.rooms) {\r\n\t\t\tlet room = Game.rooms[roomName];\r\n\t\t\troomSurveyor.surveyRoom(room);\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.log(\"An error has occured!\");\r\n\t\tconsole.log(\"message: \" + error.message);\r\n\t\tconsole.log(\"name: \" + error.name);\r\n\t\tconsole.log(\"error occured on file: \" + error.filename + \" line: \" + error.lineNumber + \" column: \" + error.columnNumber);\r\n\t\tconsole.log(\"stacktrace \" + error.stack);\r\n\t\t//console.log(JSON.stringify(error));\r\n\t}\r\n\r\n\tconsole.log(\"loop end\");\r\n};\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modules/creepRequisitioner.js":
/*!*******************************************!*\
  !*** ./src/modules/creepRequisitioner.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tif (!Memory.counts.spawnQueueItems) {\r\n\t\tMemory.counts.spawnQueueItems = 0;\r\n\t}\r\n\r\n\tif (!Memory.spawnQueueItems) {\r\n\t\tMemory.spawnQueueItems = {};\r\n\t}\r\n\r\n\tif (!Memory.idleCreeps) {\r\n\t\tMemory.idleCreeps = {};\r\n\t}\r\n\r\n\tthis.addCreepToIdlePool = (room, creep) => {\r\n\t\tif (!room || !creep) {\r\n\t\t\tconsole.log('addCreepToIdlePool: invalid parameters!');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps) {\r\n\t\t\troom.memory.idleCreeps = {};\r\n\t\t}\r\n\r\n\t\tif (!creep.memory.type) {\r\n\t\t\tconsole.log('addCreepToIdlePool: unknown creep type');\r\n\t\t\tcreep.memory.type = CREEP_TYPES.UTILITY;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps[creep.memory.type]) {\r\n\t\t\troom.memory.idleCreeps[creep.memory.type] = [];\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps[creep.memory.type].includes(creep.name)) {\r\n\t\t\t//console.log('adding creep to idle pool');\r\n\t\t\troom.memory.idleCreeps[creep.memory.type].push(creep.name);\r\n\t\t\tMemory.idleCreeps[creep.name] = creep.name;\r\n\t\t\tcreep.memory.role = 'idle';\r\n\t\t} else {\r\n\t\t\tMemory.idleCreeps[creep.name] = creep.name;\r\n\t\t\t//console.log('creep already in idle pool');\r\n\t\t}\r\n\t};\r\n\r\n\tthis.requestCreep = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('requestCreep: invalid parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet creep = this.getIdleCreep(room, type, memory);\r\n\r\n\t\tif (creep) {\r\n\t\t\treturn creep;\r\n\t\t}\r\n\r\n\t\treturn this.addCreepToRoomSpawnQueue(room, type, memory);\r\n\t};\r\n\r\n\tthis.getIdleCreep = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('getIdleCreep: invalid parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!room.memory.idleCreeps) {\r\n\t\t\troom.memory.idleCreeps = {};\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet idleCreeps = room.memory.idleCreeps[type];\r\n\r\n\t\tif (!idleCreeps) {\r\n\t\t\tconsole.log(`can not find idleCreeps type in room memory. type ${type} roomMemory: ${JSON.stringify(room.memory.idleCreeps)}`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet idleIndex = 0,\r\n\t\t\tidleLength = idleCreeps.length;\r\n\r\n\t\twhile (idleIndex < idleLength) {\r\n\t\t\tlet idleCreep = idleCreeps.shift();\r\n\r\n\t\t\tlet creep = Game.creeps[idleCreep];\r\n\t\t\tif (creep) {\r\n\t\t\t\tconsole.log(`idle creep found. creep: ${creep.name} type:${type}`);\r\n\t\t\t\tcreep.memory = memory;\r\n\t\t\t\troom.memory.idleCreeps[type] = idleCreeps;\r\n\r\n\t\t\t\tif (Memory.idleCreeps[creep.name]) {\r\n\t\t\t\t\tdelete Memory.idleCreeps[creep.name];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn creep;\r\n\t\t\t}\r\n\r\n\t\t\tidleIndex++;\r\n\t\t}\r\n\t\troom.memory.idleCreeps[type] = idleCreeps;\r\n\r\n\t\tconsole.log(`no idle creep found in idleCreep Queue of type: ${type}`);\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\tthis.addCreepToRoomSpawnQueue = (room, type, memory) => {\r\n\t\tif (!room || !type || !memory) {\r\n\t\t\tconsole.log('addCreepToRoomSpawnQueue: Invalid parameters!');\r\n\t\t}\r\n\r\n\t\tlet spawnQueueItem = {\r\n\t\t\tid: this.getNextSpawnQueueItemId(),\r\n\t\t\troomName: room.name,\r\n\t\t\ttype,\r\n\t\t\tmemory,\r\n\t\t\tspawnId: null,\r\n\t\t};\r\n\r\n\t\t// reference for the creep\r\n\t\tspawnQueueItem.memory.spawnQueueItemId = spawnQueueItem.id;\r\n\r\n\t\tMemory.spawnQueueItems[spawnQueueItem.id] = spawnQueueItem;\r\n\r\n\t\tif (!room.memory.spawnQueue) {\r\n\t\t\troom.memory.spawnQueue = [];\r\n\t\t}\r\n\r\n\t\troom.memory.spawnQueue.push(spawnQueueItem.id);\r\n\r\n\t\treturn spawnQueueItem;\r\n\t};\r\n\r\n\tthis.getNextSpawnQueueItemId = () => {\r\n\t\treturn `sqi${Memory.counts.spawnQueueItems++}`;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/creepRequisitioner.js?");

/***/ }),

/***/ "./src/modules/move.js":
/*!*****************************!*\
  !*** ./src/modules/move.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\r\n\tthis.findPathTo = (startPos, endPos, disallowContainer, avoidCreeps, noRoads) => {\r\n\t\tif (!startPos || !endPos) {\r\n\t\t\tconsole.log('move.findPathTo: Invalid start or end positions.');\r\n\t\t}\r\n\r\n\t\tlet goal = { pos: endPos, range: 1 };\r\n\r\n\t\treturn PathFinder.search(startPos, goal, {\r\n\t\t\t// We need to set the defaults costs higher so that we\r\n\t\t\t// can set the road cost lower in `roomCallback`\r\n\t\t\tplainCost: noRoads ? 1 : 2,\r\n\t\t\tswampCost: 10,\r\n\r\n\t\t\troomCallback: function (roomName) {\r\n\t\t\t\tlet room = Game.rooms[roomName];\r\n\t\t\t\t// In this example `room` will always exist, but since\r\n\t\t\t\t// PathFinder supports searches which span multiple rooms\r\n\t\t\t\t// you should be careful!\r\n\t\t\t\tif (!room) return;\r\n\t\t\t\tlet costs = new PathFinder.CostMatrix();\r\n\r\n\t\t\t\troom.find(FIND_STRUCTURES).forEach(function (struct) {\r\n\t\t\t\t\tif (struct.structureType === STRUCTURE_ROAD && noRoads) {\r\n\t\t\t\t\t\t// Favor roads over plain tiles\r\n\t\t\t\t\t\tcosts.set(struct.pos.x, struct.pos.y, 1);\r\n\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t((disallowContainer && struct.structureType === STRUCTURE_CONTAINER) || struct.structureType !== STRUCTURE_CONTAINER) &&\r\n\t\t\t\t\t\t(struct.structureType !== STRUCTURE_RAMPART || !struct.my)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// Can't walk through non-walkable buildings\r\n\t\t\t\t\t\tcosts.set(struct.pos.x, struct.pos.y, 0xff);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Avoid creeps in the room\r\n\t\t\t\tif (avoidCreeps) {\r\n\t\t\t\t\troom.find(FIND_CREEPS).forEach(function (creep) {\r\n\t\t\t\t\t\tcosts.set(creep.pos.x, creep.pos.y, 0xff);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn costs;\r\n\t\t\t},\r\n\t\t});\r\n\t};\r\n\r\n\tthis.getTotalTravelTime = (path, totalBodyCount, totalMove, totalEmptyCarry = 0) => {\r\n\t\tif (!path || !totalBodyCount || !totalMove) {\r\n\t\t\tconsole.log('move.calculateCreepMovement: Invalid paramerers.');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar fatigue = 0,\r\n\t\t\ttotalTime = 0;\r\n\r\n\t\tpath.forEach((pos) => {\r\n\t\t\tvar isSwamp = false,\r\n\t\t\t\tisRoad = false,\r\n\t\t\t\tlook = pos.look();\r\n\r\n\t\t\t// increase by 1 for each tick\r\n\t\t\ttotalTime++;\r\n\r\n\t\t\tif (look) {\r\n\t\t\t\tlook.forEach((item) => {\r\n\t\t\t\t\tif (item.type === 'terrain' && item.terrain === 'swamp') {\r\n\t\t\t\t\t\tisSwamp = true;\r\n\t\t\t\t\t} else if (item.type === 'structure' && item.structureType === STRUCTURE_ROAD) {\r\n\t\t\t\t\t\tisRoad = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet weight = totalBodyCount - (totalMove + totalEmptyCarry);\r\n\t\t\t\tlet terrainFactor = isSwamp ? 4 : 2;\r\n\t\t\t\tlet roadFactor = isRoad ? 0.5 : 0;\r\n\t\t\t\tlet fatigue = weight * (terrainFactor / roadFactor);\r\n\t\t\t\tconst recovery = totalMove * 2;\r\n\r\n\t\t\t\tconst recoveryTime = floor(fatigue / recovery);\r\n\t\t\t\ttotalTime + recoveryTime;\r\n\r\n\t\t\t\t//F = 2 * (W * K - M)\r\n\t\t\t\t// Where:\r\n\t\t\t\t// \tF = initial fatigue value\r\n\t\t\t\t// \tW = creep weight (Number of body parts, excluding MOVE and empty CARRY parts)\r\n\t\t\t\t// \tK = terrain factor (0.5x for road, 1x for plain, 5x for swamp)\r\n\t\t\t\t// \tM = number of MOVE parts\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn totalTime;\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/move.js?");

/***/ }),

/***/ "./src/modules/resource.js":
/*!*********************************!*\
  !*** ./src/modules/resource.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* resource.js */\r\nmodule.exports = function () {\r\n\tif (!Memory.resourceOrders) {\r\n\t\tMemory.resourceOrders = {};\r\n\t}\r\n\r\n\tif (!Memory.resourceOrderItems) {\r\n\t\tMemory.resourceOrderItems = {};\r\n\t}\r\n\r\n\tfor (const i in Memory.resourceOrders) {\r\n\t\tlet resourceOrder;\r\n\t}\r\n\r\n\tthis.createResourceOrder = (room, destinationId, type, amount) => {\r\n\t\tif (!room || !type || !amount) {\r\n\t\t\tconsole.log('createResourceOrder: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t//console.log(`createResourceOrder: ${JSON.stringify({ room, destinationId, type, amount })})`);\r\n\r\n\t\tconst destination = Game.getObjectById(destinationId);\r\n\r\n\t\tif (!destination) {\r\n\t\t\tconsole.log(`createResourceOrder: Couldn't find destination for id: ${destinationId}`);\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders) {\r\n\t\t\troom.memory.resourceOrders = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type]) {\r\n\t\t\troom.memory.resourceOrders[type] = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type][destination.structureType]) {\r\n\t\t\troom.memory.resourceOrders[type][destination.structureType] = [];\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = {\r\n\t\t\tid: this.getNextResourceOrderId(),\r\n\t\t\tdestinationId,\r\n\t\t\ttype,\r\n\t\t\tamount,\r\n\t\t\tamountPending: 0,\r\n\t\t\tamountFulfilled: 0,\r\n\t\t\torderItemIds: {},\r\n\t\t\tcreatedTime: Game.time,\r\n\t\t};\r\n\r\n\t\tif (!Memory[destination.structureType]) {\r\n\t\t\tMemory[destination.structureType] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[destination.structureType][destination.id]) {\r\n\t\t\tMemory[destination.structureType][destination.id] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[destination.structureType][destination.id].resourceOrderIds) {\r\n\t\t\tMemory[destination.structureType][destination.id].resourceOrderIds = {};\r\n\t\t}\r\n\r\n\t\tif (destination.structureType !== STRUCTURE_CONTROLLER && Memory[destination.structureType][destination.id].resourceOrderIds[type]) {\r\n\t\t\tlet orderId = Memory[destination.structureType][destination.id].resourceOrderIds[type];\r\n\t\t\tlet existingOrder = Memory.resourceOrders[orderId];\r\n\r\n\t\t\t// if it exists there has been an issue with making another order at the structure side\r\n\t\t\tif (existingOrder) {\r\n\t\t\t\tconsole.log(`found existing resource order id: ${existingOrder.id}`);\r\n\t\t\t\treturn existingOrder;\r\n\t\t\t} //else continue as normal as it will be overridden anyways\r\n\t\t}\r\n\r\n\t\tMemory.resourceOrders[resourceOrder.id] = resourceOrder;\r\n\r\n\t\troom.memory.resourceOrders[type][destination.structureType].push(resourceOrder.id);\r\n\r\n\t\tMemory[destination.structureType][destination.id].resourceOrderIds[type] = resourceOrder.id;\r\n\r\n\t\treturn resourceOrder;\r\n\t};\r\n\r\n\tthis.findNextResourceOrderToFulfill = (room, creep, type, amount) => {\r\n\t\tif (!room || !creep || !type || !amount) {\r\n\t\t\tconsole.log('findNextResourceOrderToFulfill: Invalid parameters');\r\n\t\t}\r\n\r\n\t\tthis.checkRoomForResourceOrder(room, type);\r\n\r\n\t\tvar strucIndex = 0,\r\n\t\t\torder = null;\r\n\t\tconsole.log(`looking for strucIndex: ${strucIndex}, RESOURCE_ORDER_STRUCTURE_PRIORITY length: ${RESOURCE_ORDER_STRUCTURE_PRIORITY.length}`);\r\n\r\n\t\t//for(var strucIndex = 0; strucIndex < RESOURCE_ORDER_STRUCTURE_PRIORITY.length )\r\n\r\n\t\twhile (!order && strucIndex < RESOURCE_ORDER_STRUCTURE_PRIORITY.length) {\r\n\t\t\tconst structure = RESOURCE_ORDER_STRUCTURE_PRIORITY[strucIndex];\r\n\r\n\t\t\tconsole.log(\r\n\t\t\t\t`looking for ${structure}, strucIndex: ${strucIndex}, RESOURCE_ORDER_STRUCTURE_PRIORITY length: ${RESOURCE_ORDER_STRUCTURE_PRIORITY.length}`\r\n\t\t\t);\r\n\r\n\t\t\tif (!room.memory.resourceOrders[type][structure]) {\r\n\t\t\t\troom.memory.resourceOrders[type][structure] = [];\r\n\t\t\t}\r\n\r\n\t\t\tif (room.memory.resourceOrders[type][structure].length) {\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t`room resourceOrder of type: ${type}, of struc: ${structure}, length: ${room.memory.resourceOrders[type][structure].length}`\r\n\t\t\t\t);\r\n\t\t\t\tvar queueIndex = 0;\r\n\t\t\t\twhile (!order && queueIndex < room.memory.resourceOrders[type][structure].length) {\r\n\t\t\t\t\tvar orderId = room.memory.resourceOrders[type][structure][queueIndex];\r\n\r\n\t\t\t\t\tconsole.log(`looking for order with id ${orderId}, queueIndex: ${queueIndex}`);\r\n\r\n\t\t\t\t\tvar currentOrder = Memory.resourceOrders[orderId];\r\n\r\n\t\t\t\t\tif (!currentOrder) {\r\n\t\t\t\t\t\troom.memory.resourceOrders[type][structure].shift();\r\n\t\t\t\t\t} else if (currentOrder.amountPending + currentOrder.amountFulfilled < currentOrder.amount) {\r\n\t\t\t\t\t\torder = currentOrder;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tqueueIndex++;\r\n\t\t\t\t}\r\n\t\t\t\tqueue = room.memory.resourceOrders[type][structure];\r\n\t\t\t}\r\n\t\t\t//test\r\n\t\t\tstrucIndex++;\r\n\t\t}\r\n\r\n\t\tif (!order) {\r\n\t\t\tif (type === RESOURCE_ENERGY) {\r\n\t\t\t\t// for now go to controller this will probably need to chnage to include other destinations\r\n\t\t\t\torder = this.createResourceOrder(room, room.controller.id, type, amount);\r\n\t\t\t} else {\r\n\t\t\t\t//TODO stick it in storage;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log(`findNextResourceOrderToFulfill: order: ${JSON.stringify(order)}`);\r\n\r\n\t\tlet item = this.createResourceOrderItem(creep, type, amount, order);\r\n\r\n\t\treturn item;\r\n\t};\r\n\r\n\tthis.checkRoomForResourceOrder = (room, type) => {\r\n\t\tif (!room || !type) {\r\n\t\t\tconsole.log('checkRoomForResourceOrder: Invalid parameters');\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders) {\r\n\t\t\troom.memory.resourceOrders = {};\r\n\t\t}\r\n\r\n\t\tif (!room.memory.resourceOrders[type]) {\r\n\t\t\troom.memory.resourceOrders[type] = {};\r\n\t\t}\r\n\t};\r\n\r\n\tthis.createResourceOrderItem = (creep, type, amount, order) => {\r\n\t\tif (!creep || !type || !amount || !order) {\r\n\t\t\tconsole.log('createResourceOrderItem: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst amountLeft = order.amount - (order.amountPending + order.amountFulfilled);\r\n\r\n\t\tif (amountLeft <= 0) {\r\n\t\t\tconsole.log('createResourceOrderItem: amountLeft is less than originally requested!');\r\n\t\t\tthis.deleteOrder(order);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// check if it's the full creep carry amount to be fulfilled\r\n\t\tconst amountToUpdate = amount > amountLeft ? amountLeft : amount;\r\n\r\n\t\tlet resourceOrderItem = {\r\n\t\t\tid: this.getNextResourceOrderItemId(),\r\n\t\t\tamount: amountToUpdate,\r\n\t\t\ttype,\r\n\t\t\torderId: order.id,\r\n\t\t\tcreepName: creep.name,\r\n\t\t\tfulfilled: false,\r\n\t\t\tcreatedTime: Game.time,\r\n\t\t};\r\n\r\n\t\tconsole.log(`createResourceOrderItem: order: ${JSON.stringify(order)}`);\r\n\r\n\t\torder.amountPending += amountToUpdate;\r\n\t\torder.orderItemIds[resourceOrderItem.id] = resourceOrderItem.id;\r\n\r\n\t\tMemory.resourceOrders[order.id] = order;\r\n\t\tMemory.resourceOrderItems[resourceOrderItem.id] = resourceOrderItem;\r\n\t\tcreep.memory.resourceOrderItemId = resourceOrderItem.id;\r\n\r\n\t\treturn resourceOrderItem;\r\n\t};\r\n\r\n\tthis.fulfillResourceOrderItem = (creep) => {\r\n\t\tlet orderItem = Memory.resourceOrderItems[creep.memory.resourceOrderItemId];\r\n\r\n\t\tif (!orderItem) {\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\treturn false;\r\n\t\t\t// reassign creep to new order?\r\n\t\t\t// how to determine room etc?\r\n\t\t\t//this.findNextResourceOrderToFulfill(creep)\r\n\t\t}\r\n\r\n\t\tlet order = Memory.resourceOrders[orderItem.orderId];\r\n\r\n\t\tif (!order) {\r\n\t\t\tconsole.log('fulfillResourceOrderItem: could not find order to fulfill!');\r\n\t\t\tdelete Memory.resourceOrderItems[creep.memory.resourceOrderItemId];\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet structure = Game.getObjectById(order.destinationId);\r\n\r\n\t\tif (!structure) {\r\n\t\t\tconsole.log('fulfillResourceOrderItem: Could not find structure for  resource order!');\r\n\r\n\t\t\tthis.deleteOrder(order);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet transferResult = creep.transfer(structure, order.type, orderItem.amount);\r\n\r\n\t\tswitch (transferResult) {\r\n\t\t\tcase OK:\r\n\t\t\t\tif (order.amountFulfilled + orderItem.amount >= order.amount) {\r\n\t\t\t\t\tthis.deleteOrder(order);\r\n\t\t\t\t} else {\r\n\t\t\t\t\torderItem.fulfilled = true;\r\n\t\t\t\t\torder.amountFulfilled += orderItem.amount;\r\n\t\t\t\t\torder.amountPending -= orderItem.amount;\r\n\r\n\t\t\t\t\tMemory.resourceOrderItems[creep.memory.resourceOrderItemId] = orderItem;\r\n\t\t\t\t\tMemory.resourceOrders[orderItem.orderId] = order;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_NOT_ENOUGH_RESOURCES:\r\n\t\t\t\tthis.checkCreepAmount(creep, orderItem, order);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_FULL:\r\n\t\t\t\tthis.deleteOrder(order);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ERR_NOT_IN_RANGE:\r\n\t\t\t\treturn transferResult;\r\n\t\t\tcase ERR_INVALID_ARGS:\r\n\t\t\t\tthis.checkCreepAmount(creep, orderItem, order);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.checkCreepAmount = (creep, orderItem, order) => {\r\n\t\t// find out what resources you do have\r\n\t\tvar creepAmount = creep.store.getUsedCapacity(order.type);\r\n\r\n\t\t// amend the order item\r\n\t\tif (creepAmount && creepAmount > 0) {\r\n\t\t\torder.amountPending -= creepAmount + orderItem.amount;\r\n\t\t\torderItem.amount = creepAmount;\r\n\t\t\torderItem.fulfilled = true;\r\n\t\t\torder.amountFulfilled += orderItem.amount;\r\n\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\tMemory.resourceOrderItems[creep.memory.resourceOrderItemId] = orderItem;\r\n\t\t\tMemory.resourceOrders[orderItem.orderId] = order;\r\n\t\t} else {\r\n\t\t\t// or delete orderItem if no resources\r\n\t\t\tthis.deleteOrderItem(orderItem);\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getNextResourceOrderId = () => {\r\n\t\tif (!Memory.counts.resourceOrders) {\r\n\t\t\tMemory.counts.resourceOrders = 0;\r\n\t\t}\r\n\t\treturn `ro${Memory.counts.resourceOrders++}`;\r\n\t};\r\n\r\n\tthis.getNextResourceOrderItemId = () => {\r\n\t\tif (!Memory.counts.resourceOrderItems) {\r\n\t\t\tMemory.counts.resourceOrderItems = 0;\r\n\t\t}\r\n\t\treturn `roi${Memory.counts.resourceOrderItems++}`;\r\n\t};\r\n\r\n\tthis.deleteOrderItem = (orderItem) => {\r\n\t\tif (!orderItem) {\r\n\t\t\tconsole.log('deleteOrderItem: Invalid Parameters!');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = Memory.resourceOrders[orderItem.orderId];\r\n\r\n\t\tif (resourceOrder) {\r\n\t\t\tif (!resourceOrder.fulfilled) {\r\n\t\t\t\tresourceOrder.pendingAmount -= orderItem.amount;\r\n\t\t\t\tdelete resourceOrder.orderItemIds[orderItem.id];\r\n\t\t\t\tMemory.resourceOrders[orderItem.orderId] = resourceOrder;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet creep = Game.creeps[orderItem.creepName];\r\n\r\n\t\tif (creep) {\r\n\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t}\r\n\r\n\t\tif (Memory.resourceOrderItems[orderItem.id]) {\r\n\t\t\tdelete Memory.resourceOrderItems[orderItem.id];\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tthis.deleteOrder = (order) => {\r\n\t\tif (!order) {\r\n\t\t\tconsole.log('deleteOrder: Invalid parameter!');\r\n\t\t}\r\n\r\n\t\tif (order.orderItemIds && order.orderItemIds.length) {\r\n\t\t\torder.orderItemIds.foreach((itemId) => {\r\n\t\t\t\tlet orderItem = Memory.resourceOrderItems[itemId];\r\n\r\n\t\t\t\tif (orderItem) {\r\n\t\t\t\t\tlet creep = Game.creeps[orderItem.creepName];\r\n\r\n\t\t\t\t\tif (creep) {\r\n\t\t\t\t\t\tdelete creep.memory.resourceOrderItemId;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdelete Memory.resourceOrderItems[itemId];\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// need to do a check on actual strucutres indiviudually to check if resourceOrder still exists grr!\r\n\t\tlet struc = Game.getObjectById(order.destinationId);\r\n\r\n\t\tif (struc) {\r\n\t\t\tif (Memory[struc.structureType][struc.id]) {\r\n\t\t\t\tdelete Memory[struc.structureType][struc.id].resourceOrderId;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (Memory.resourceOrders[order.id]) {\r\n\t\t\tdelete Memory.resourceOrders[order.id];\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tthis.getStructureResourceOrderId = (struc, type) => {\r\n\t\tif (!struc || !type) {\r\n\t\t\tconsole.log('getStructureResourceOrderId: Invalid parameters!');\r\n\t\t}\r\n\r\n\t\tif (!Memory[struc.structureType]) {\r\n\t\t\tMemory[struc.structureType] = {};\r\n\t\t}\r\n\r\n\t\tif (!Memory[struc.structureType][struc.id]) {\r\n\t\t\tMemory[struc.structureType][struc.id] = {};\r\n\t\t}\r\n\r\n\t\tlet strucMemory = Memory[struc.structureType][struc.id];\r\n\r\n\t\tif (!strucMemory.resourceOrderIds) {\r\n\t\t\tstrucMemory.resourceOrderIds = {};\r\n\t\t}\r\n\r\n\t\treturn strucMemory.resourceOrderIds[type];\r\n\t};\r\n\r\n\tthis.getResourceOrderItemDestination = (resourceOrderItemId) => {\r\n\t\tif (!resourceOrderItemId) {\r\n\t\t\tconsole.log('getResourceOrderItemDestination: Invalid parameters');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrderItem = Memory.resourceOrderItems[resourceOrderItemId];\r\n\r\n\t\tif (!resourceOrderItem) {\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No resource order item found belonging to id: ${resourceOrderItemId}`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet resourceOrder = Memory.resourceOrders[resourceOrderItem.orderId];\r\n\r\n\t\tif (!resourceOrder) {\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No resource order found belonging to id: ${resourceOrderItem.orderId}`);\r\n\r\n\t\t\tthis.deleteOrderItem(resourceOrderItem);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet destination = Game.getObjectById(resourceOrder.destinationId);\r\n\r\n\t\tif (!destination) {\r\n\t\t\t// no destination found remove order\r\n\t\t\tconsole.log(`getResourceOrderItemDestination: No destination found for resource order belonging to id: ${resourceOrder.destinationId}`);\r\n\t\t\tthis.deleteOrder(resourceOrder);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn destination;\r\n\t};\r\n\r\n\t// find and remove any roi belonging to dead creeps\r\n\tfor (const roi in Memory.resourceOrderItems) {\r\n\t\tlet orderItem = Memory.resourceOrderItems[roi];\r\n\t\tif (!Game.creeps[orderItem.creepName]) {\r\n\t\t\tthis.deleteOrderItem(orderItem);\r\n\t\t}\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/resource.js?");

/***/ }),

/***/ "./src/modules/roomSurveyor.js":
/*!*************************************!*\
  !*** ./src/modules/roomSurveyor.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function (memory, game) {\r\n\tthis.memory = memory;\r\n\tthis.game = game;\r\n\r\n\tthis.sources = [];\r\n\tthis.minerals = [];\r\n\tthis.exits = [];\r\n\tthis.roomTerrain = null;\r\n\r\n\tvar Helper = __webpack_require__(/*! ../common/helper */ \"./src/common/helper.js\");\r\n\tthis.helper = new Helper();\r\n\r\n\tthis.surveyRoom = function (room) {\r\n\t\t/*\r\n        grade a room on\r\n        - resources (sources, minerals)\r\n        - resource placement (far apart)\r\n        - controller placement in conjunction with resources\r\n        - free space\r\n        - defendability (room accessibility, solid rock placement)\r\n\r\n        approach\r\n        - scan each block in the room\r\n        - determine the best path between resources and controller\r\n        - use that as a basis of base placement\r\n\r\n    */\r\n\r\n\t\t// x, y 0 - 49\r\n\r\n\t\tif (room) {\r\n\t\t\tif (this.memory.roomSurveyData) {\r\n\t\t\t\tthis.roomSurveyData = this.memory.roomSurveyData;\r\n\t\t\t} else {\r\n\t\t\t\tthis.roomSurveyData = {\r\n\t\t\t\t\troom: room.name,\r\n\t\t\t\t\tprogressPos: { x: 0, y: 0 },\r\n\t\t\t\t\texitPathPosCounts: {},\r\n\t\t\t\t\tpositionData: {},\r\n\t\t\t\t\ttotalExits: 0,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlet x = this.roomSurveyData.progressPos.x,\r\n\t\t\t\ty = this.roomSurveyData.progressPos.x;\r\n\r\n\t\t\tif (!this.roomTerrain) {\r\n\t\t\t\tthis.roomTerrain = room.getTerrain();\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(`terrainData = ${JSON.stringify(this.roomTerrain)}`);\r\n\r\n\t\t\tthis.sources = room.find(FIND_SOURCES);\r\n\r\n\t\t\t//console.log(`sources = ${JSON.stringify(this.sources)}`);\r\n\r\n\t\t\tthis.minerals = room.find(FIND_MINERALS);\r\n\r\n\t\t\t//console.log(`minerals = ${JSON.stringify(this.minerals)}`);\r\n\r\n\t\t\tthis.exits = room.find(FIND_EXIT);\r\n\r\n\t\t\t//console.log(`exits = ${JSON.stringify(this.exits)}`);\r\n\r\n\t\t\tthis.roomSurveyData.totalExits = this.exits.length;\r\n\r\n\t\t\tlet increment = 0;\r\n\r\n\t\t\t// scan each position\r\n\t\t\twhile (increment < COORDINATES_MAX_SIZE) {\r\n\t\t\t\t//console.log(`increment = ${JSON.stringify(increment)}`);\r\n\t\t\t\tif (increment === 0) {\r\n\t\t\t\t\t// check position\r\n\r\n\t\t\t\t\t//console.log(`first coordinate ${x}:${y} `);\r\n\t\t\t\t\tvar roomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tincrement++;\r\n\r\n\t\t\t\tx = increment;\r\n\t\t\t\t// check position\r\n\t\t\t\t//console.log(`first coordinate ${x}:${y} `);\r\n\t\t\t\tvar roomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\r\n\t\t\t\ty = increment;\r\n\t\t\t\t//console.log(`second coordinate ${x}:${y} `);\r\n\t\t\t\troomPosition = room.getPositionAt(x, y);\r\n\t\t\t\t//console.log(`roomPosition = ${JSON.stringify(roomPosition)}`);\r\n\t\t\t\tthis.roomSurveyData.positionData[this.helper.getPosName(x, y)] = this.checkPosition(room.getPositionAt(x, y));\r\n\r\n\t\t\t\t//console.log(\"setting memory\");\r\n\t\t\t\t//console.log(`increment = ${JSON.stringify(increment)}`);\r\n\t\t\t\tthis.memory.roomSurveyData = this.roomSurveyData;\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(\"setting structure map\");\r\n\t\t\tthis.generateStructureMap(this.roomSurveyData);\r\n\r\n\t\t\tthis.memory.roomSurveyData = this.roomSurveyData;\r\n\r\n\t\t\troom.memory.surveyData = this.roomSurveyData;\r\n\t\t}\r\n\r\n\t\tconsole.log(`roomSurveyData = ${JSON.stringify(this.roomSurveyData)}`);\r\n\t\treturn this.roomSurveyData;\r\n\t};\r\n\r\n\tthis.checkPosition = function (pos) {\r\n\t\t//console.log(`checkPostitionStart pos = ${JSON.stringify(pos)}`);\r\n\t\tlet posSurveyData = {\r\n\t\t\tcanBuild: true,\r\n\t\t\tcanTravel: true,\r\n\t\t\tx: pos.x,\r\n\t\t\ty: pos.y,\r\n\t\t};\r\n\r\n\t\tvar terrainData = this.checkPositionTerrain(pos);\r\n\r\n\t\tposSurveyData = { ...posSurveyData, ...terrainData };\r\n\r\n\t\tif (posSurveyData.canTravel) {\r\n\t\t\tvar distanceData = this.getPositionDistanceData(pos);\r\n\r\n\t\t\tposSurveyData = { ...posSurveyData, ...distanceData };\r\n\t\t}\r\n\r\n\t\treturn posSurveyData;\r\n\t};\r\n\r\n\tthis.checkPositionTerrain = function (pos) {\r\n\t\t//console.log(\"checkPositionTerrain\");\r\n\t\tconst posTerrain = this.roomTerrain.get(pos.x, pos.y);\r\n\t\t//console.log(`posTerrain: ${JSON.stringify(posTerrain)}`);\r\n\t\tswitch (posTerrain) {\r\n\t\t\tcase 0: //plain\r\n\t\t\t\t//console.log(\"checkPositionTerrain Plain\");\r\n\t\t\t\treturn { canBuild: this.helper.isPosNearEdge(pos.x, pos.y), terrain: \"Plain\" };\r\n\t\t\tcase TERRAIN_MASK_WALL: //wall\r\n\t\t\t\t//console.log(\"checkPositionTerrain Wall\");\r\n\t\t\t\treturn { canBuild: false, canTravel: false, terrain: \"Wall\" };\r\n\t\t\tcase TERRAIN_MASK_SWAMP: //swamp\r\n\t\t\t\t//console.log(\"checkPositionTerrain Swamp\");\r\n\t\t\t\treturn { canBuild: this.helper.isPosNearEdge(pos.x, pos.y), canTravel: false, terrain: \"Swamp\" };\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getPositionDistanceData = function (pos) {\r\n\t\t//console.log(\"getPositionDistanceData\");\r\n\t\tlet room = this.game.rooms[pos.roomName];\r\n\r\n\t\tlet positionDistanceData = {\r\n\t\t\tdistances: {\r\n\t\t\t\tsources: [],\r\n\t\t\t\tmineral: [],\r\n\t\t\t\tcontroller: [],\r\n\t\t\t\texits: [],\r\n\t\t\t},\r\n\t\t\ttotalDistance: 0,\r\n\t\t\tclosestExit: 0,\r\n\t\t};\r\n\r\n\t\tthis.sources.forEach(function (source) {\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: source.pos, range: 1 });\r\n\t\t\tpositionDistanceData.distances.sources.push({ id: source.id, cost: ret.cost });\r\n\t\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\t\t});\r\n\r\n\t\t//console.log(\"getPositionDistanceData got sources\");\r\n\r\n\t\tthis.minerals.forEach(function (mineral) {\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: mineral.pos, range: 1 });\r\n\t\t\tpositionDistanceData.distances.mineral = { id: mineral.id, cost: ret.cost };\r\n\t\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\t\t});\r\n\r\n\t\t//console.log(\"getPositionDistanceData got minerals\");\r\n\r\n\t\tfor (const i in this.exits) {\r\n\t\t\tconst exit = this.exits[i];\r\n\t\t\t//console.log(`exit: ${JSON.stringify(exit)}`);\r\n\t\t\tvar ret = PathFinder.search(pos, { pos: exit, range: 1 });\r\n\r\n\t\t\tif (ret) {\r\n\t\t\t\tpositionDistanceData.distances.exits.push({ id: this.helper.getPosName(exit.x, exit.y), cost: ret.cost });\r\n\r\n\t\t\t\tif (!positionDistanceData.totalExitDistance) {\r\n\t\t\t\t\tpositionDistanceData.totalExitDistance = 0;\r\n\t\t\t\t}\r\n\t\t\t\tpositionDistanceData.totalExitDistance += ret.cost;\r\n\r\n\t\t\t\tif (positionDistanceData.closestExit === 0) {\r\n\t\t\t\t\tpositionDistanceData.closestExit = ret.cost;\r\n\t\t\t\t} else if (positionDistanceData.closestExit > ret.cost) {\r\n\t\t\t\t\tpositionDistanceData.closestExit = ret.cost;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ret.path) {\r\n\t\t\t\t\tfor (let j in ret.path) {\r\n\t\t\t\t\t\tconst pathPos = ret.path[j];\r\n\t\t\t\t\t\tlet id = this.helper.getPosName(pathPos.x, pathPos.y);\r\n\t\t\t\t\t\tthis.roomSurveyData.exitPathPosCounts[id]\r\n\t\t\t\t\t\t\t? this.roomSurveyData.exitPathPosCounts[id]++\r\n\t\t\t\t\t\t\t: (this.roomSurveyData.exitPathPosCounts[id] = 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(`No path found to exit for ${JSON.stringify(exit)}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//console.log(\"getPositionDistanceData got exits\");\r\n\r\n\t\t//console.log(`pos: ${JSON.stringify(pos)}`);\r\n\t\t//console.log(`roomController: ${JSON.stringify(room.controller)}`);\r\n\r\n\t\tvar ret = PathFinder.search(pos, { pos: room.controller.pos, range: 1 });\r\n\t\tpositionDistanceData.distances.controller = { id: room.controller.id, cost: ret.cost };\r\n\t\tpositionDistanceData.totalDistance += ret.cost;\r\n\r\n\t\t//console.log(\"getPositionDistanceData end\");\r\n\r\n\t\treturn positionDistanceData;\r\n\t};\r\n\r\n\tthis.generateStructureMap = (surveyData) => {\r\n\t\tconst weights = {\r\n\t\t\tspawn: { nearSource: 0.3, nearSources: 0.3, defendability: 0.3, nearController: 0.3 },\r\n\t\t};\r\n\t\t// how to determine best placement\r\n\t\t// find best placement for\r\n\t\t//\r\n\t\t// STRUCTURE_SPAWN: \"spawn\",\r\n\t\t// ideally between sources and preferably in a defensive position near controller\r\n\t\tlet nearestSourceDistance = 1000,\r\n\t\t\tnearestSourceDistancePosId = null,\r\n\t\t\tnearestTotalSourceDistance = 1000,\r\n\t\t\tbestSpawnWeight = 1000,\r\n\t\t\tidealSpawnPosition = null;\r\n\r\n\t\tfor (const i in surveyData.positionData) {\r\n\t\t\tlet positionData = surveyData.positionData[i],\r\n\t\t\t\ttotalSourceDistance = 0,\r\n\t\t\t\tposNearestSourceDistance = 1000;\r\n\r\n\t\t\tif (positionData.canTravel && positionData.canBuild) {\r\n\t\t\t\t//console.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\t\t\t\tpositionData.distances.sources.forEach((distance) => {\r\n\t\t\t\t\t// checking globally nearest source distance\r\n\t\t\t\t\tif (distance.cost < nearestSourceDistance) {\r\n\t\t\t\t\t\tnearestSourceDistance = distance.cost;\r\n\t\t\t\t\t\tposNearestSourceDistance = distance.cost;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// checking locally nearest source distance\r\n\t\t\t\t\tif (distance.cost < posNearestSourceDistance) {\r\n\t\t\t\t\t\tposNearestSourceDistance = distance.cost;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// finding total source distance\r\n\t\t\t\t\ttotalSourceDistance += distance.cost;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet controllerDistance = positionData.distances.controller.cost;\r\n\r\n\t\t\t\tlet exitPathCount = this.getSurroundingPositionExitPathCounts(positionData.x, positionData.y);\r\n\r\n\t\t\t\tconst weightNearestSourceDistance = weights.spawn.nearSource * posNearestSourceDistance,\r\n\t\t\t\t\tweightTotalNearestSourceDistance = weights.spawn.nearSources * totalSourceDistance,\r\n\t\t\t\t\tweightControllerDistance = weights.spawn.nearController * controllerDistance,\r\n\t\t\t\t\tweightDefendability = weights.spawn.defendability * exitPathCount;\r\n\r\n\t\t\t\tlet spawnWeight = weightNearestSourceDistance + weightTotalNearestSourceDistance + weightControllerDistance + weightDefendability;\r\n\r\n\t\t\t\tpositionData.weightNearestSourceDistance = weightNearestSourceDistance;\r\n\t\t\t\tpositionData.weightTotalNearestSourceDistance = weightTotalNearestSourceDistance;\r\n\t\t\t\tpositionData.weightControllerDistance = weightControllerDistance;\r\n\t\t\t\tpositionData.weightDefendability = weightDefendability;\r\n\t\t\t\tpositionData.spawnWeight = spawnWeight;\r\n\r\n\t\t\t\tif (spawnWeight < bestSpawnWeight) {\r\n\t\t\t\t\tbestSpawnWeight = spawnWeight;\r\n\t\t\t\t\tidealSpawnPosition = { id: i, x: positionData.x, y: positionData.y };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!idealSpawnPosition) {\r\n\t\t\tconsole.log(\"generateStructureMap: can not find ideal spawn position!\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//surveyData.structureMap = this.createNewStructureMap();\r\n\t\tsurveyData.structureMap = {};\r\n\r\n\t\tlet structureArray = [];\r\n\t\t//console.log(`RESOURCE_ORDER_STRUCTURE_PRIORITY: ${JSON.stringify(RESOURCE_ORDER_STRUCTURE_PRIORITY)}`);\r\n\t\tfor (const j in RESOURCE_ORDER_STRUCTURE_PRIORITY) {\r\n\t\t\t//console.log(`type: ${JSON.stringify(type)}`);\r\n\t\t\t//console.log(`CONTROLLER_STRUCTURES: ${JSON.stringify(CONTROLLER_STRUCTURES)}`);\r\n\t\t\tconst type = RESOURCE_ORDER_STRUCTURE_PRIORITY[j];\r\n\t\t\tlet structureMax = CONTROLLER_STRUCTURES[type][8];\r\n\r\n\t\t\tfor (var i = 0; i < structureMax; i++) {\r\n\t\t\t\tstructureArray.push(type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.structureArray = structureArray;\r\n\t\tconsole.log(`structureArray: ${JSON.stringify(structureArray)}`);\r\n\r\n\t\tlet positionsToCheck = [idealSpawnPosition];\r\n\t\tlet positionsChecked = {};\r\n\r\n\t\tif (this.structureArray && idealSpawnPosition) {\r\n\t\t\twhile (this.structureArray && positionsToCheck && positionsToCheck.length > 0) {\r\n\t\t\t\tconsole.log(`positionsToCheck = ${JSON.stringify(positionsToCheck)}`);\r\n\t\t\t\t// let surroundingPositions = this.getSurroundingPositions(idealSpawnPosition.x, idealSpawnPosition.y);\r\n\r\n\t\t\t\t// for (const i in surroundingPositions) {\r\n\t\t\t\t//     var position = surroundingPositions[i];\r\n\t\t\t\t//     this.assessPosForStructure(idealSpawnPosition.x, idealSpawnPosition.y);\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tconst positionToCheck = positionsToCheck.shift();\r\n\r\n\t\t\t\tif (positionToCheck) {\r\n\t\t\t\t\tconsole.log(`positionToCheck = ${JSON.stringify(positionToCheck)}`);\r\n\r\n\t\t\t\t\tlet canBePlaced = true,\r\n\t\t\t\t\t\tid = this.helper.getPosName(positionToCheck.x, positionToCheck.y),\r\n\t\t\t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t\t\t\tif (!positionsChecked[id]) {\r\n\t\t\t\t\t\tpositionsChecked[id] = id;\r\n\r\n\t\t\t\t\t\tconsole.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\r\n\t\t\t\t\t\tif (positionData) {\r\n\t\t\t\t\t\t\t// check each surrounding pos to see if you  can build on it\r\n\t\t\t\t\t\t\t// need to think of a better way of doing this. Checking surrounding positions to see where the current position is.\r\n\r\n\t\t\t\t\t\t\tconst surroundingPositions = this.getSurroundingPositions(positionToCheck.x, positionToCheck.y);\r\n\r\n\t\t\t\t\t\t\tfor (const i in surroundingPositions) {\r\n\t\t\t\t\t\t\t\t// check is position has been checked or not and add to array to be checked if not\r\n\t\t\t\t\t\t\t\tconst surroundingPos = surroundingPositions[i],\r\n\t\t\t\t\t\t\t\t\tsurroundingPosId = this.helper.getPosName(surroundingPos.x, surroundingPos.y);\r\n\r\n\t\t\t\t\t\t\t\tif (!positionsChecked[surroundingPosId]) {\r\n\t\t\t\t\t\t\t\t\tconst surroundingPosData = this.roomSurveyData.positionData[surroundingPosId];\r\n\r\n\t\t\t\t\t\t\t\t\tif (surroundingPosData && surroundingPosData.canTravel) {\r\n\t\t\t\t\t\t\t\t\t\tpositionsToCheck.push(surroundingPos);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (!this.doesPositionHaveOtherAccess(surroundingPos.x, surroundingPos.y)) {\r\n\t\t\t\t\t\t\t\t\tcanBePlaced = false;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (canBePlaced) {\r\n\t\t\t\t\t\t\t\tlet strucType = this.structureArray.shift();\r\n\r\n\t\t\t\t\t\t\t\tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tthis.roomSurveyData.structureMap[strucType].push({ x: positionToCheck.x, y: positionToCheck.y });\r\n\t\t\t\t\t\t\t\t//console.log(`positionData = ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\t\t\t\t\t\t\t\t//console.log(`structureMap = ${JSON.stringify(this.roomSurveyData.structureMap)}`);\r\n\t\t\t\t\t\t\t\tpositionData.hasStructure = true;\r\n\t\t\t\t\t\t\t\tthis.roomSurveyData.positionData[id] = positionData;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// let variance = 0,\r\n\t\t// \tstructuresPlacedCount = 0,\r\n\t\t// \tcurrentX = idealSpawnPosition.x,\r\n\t\t// \tcurrentY = idealSpawnPosition.y,\r\n\t\t// \tstartX = idealSpawnPosition.x,\r\n\t\t// \tstartY = idealSpawnPosition.y,\r\n\t\t// \tpossiblePos = [],\r\n\t\t// \tallPosTraversed = [];\r\n\r\n\t\t// //console.log(`structureArray: ${JSON.stringify(structureArray)}`);\r\n\t\t// //console.log(`idealSpawnPosition: ${JSON.stringify(idealSpawnPosition)}`);\r\n\r\n\t\t// //this.assessPosForStructure(currentX, currentY);\r\n\t\t// //allPosTraversed.push({ x: idealSpawnPosition.x, y: idealSpawnPosition.y });\r\n\t\t// //possiblePos.push({ x: idealSpawnPosition.x, y: idealSpawnPosition.y });\r\n\t\t// structuresPlacedCount++;\r\n\r\n\t\t// if (this.structureArray && idealSpawnPosition) {\r\n\t\t// \twhile (\r\n\t\t// \t\t//structuresPlacedCount < structureArray.length &&\r\n\t\t// \t\tvariance < COORDINATES_MAX_SIZE &&\r\n\t\t// \t\tthis.structureArray\r\n\t\t// \t) {\r\n\t\t// \t\t// get corner pos\r\n\t\t// \t\tstartX++;\r\n\t\t// \t\tstartY++;\r\n\t\t// \t\tcurrentX = startX;\r\n\t\t// \t\tcurrentY = startY;\r\n\t\t// \t\tvariance = variance + 2;\r\n\t\t// \t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\r\n\t\t// \t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\t//increase side length\r\n\r\n\t\t// \t\tfor (var x = 0; x < variance; x++) {\r\n\t\t// \t\t\tcurrentX--;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var y = 0; y < variance; y++) {\r\n\t\t// \t\t\tcurrentY--;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var x = 0; x < variance; x++) {\r\n\t\t// \t\t\tcurrentX++;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tfor (var y = 1; y < variance; y++) {\r\n\t\t// \t\t\tcurrentY++;\r\n\t\t// \t\t\t//allPosTraversed.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\tif (currentX <= COORDINATES_MAX_SIZE && currentY <= COORDINATES_MAX_SIZE) {\r\n\t\t// \t\t\t\t//console.log(`${currentX},${currentY}`);\r\n\t\t// \t\t\t\tthis.assessPosForStructure(currentX, currentY);\r\n\t\t// \t\t\t\t//possiblePos.push({ x: currentX, y: currentY });\r\n\t\t// \t\t\t\tstructuresPlacedCount++;\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t// if (possiblePos) {\r\n\t\t// \tconsole.log(`possiblePos: ${JSON.stringify(possiblePos)}`);\r\n\t\t// \tconsole.log(`possiblePos length: ${JSON.stringify(possiblePos.length)}`);\r\n\t\t// }\r\n\r\n\t\t// if (allPosTraversed) {\r\n\t\t// \tconsole.log(`allPosTraversed: ${JSON.stringify(allPosTraversed)}`);\r\n\t\t// \tconsole.log(`allPosTraversed length: ${JSON.stringify(allPosTraversed.length)}`);\r\n\t\t// }\r\n\r\n\t\t//\r\n\t\t// STRUCTURE_POWER_SPAWN: \"powerSpawn\",\r\n\t\t// near spawns\r\n\t\t//\r\n\t\t// STRUCTURE_STORAGE: \"storage\",\r\n\t\t// near spawns\r\n\t\t//\r\n\t\t// STRUCTURE_TERMINAL: \"terminal\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_NUKER: \"nuker\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_LAB: \"lab\",\r\n\t\t// near storage\r\n\t\t//\r\n\t\t// STRUCTURE_FACTORY: \"factory\",\r\n\t\t// near labs\r\n\t\t//\r\n\t\t// STRUCTURE_EXTENSION: \"extension\",\r\n\t\t// near spawns & sources\r\n\t\t// STRUCTURE_TOWER: \"tower\",\r\n\t\t// near spawns and extensions\r\n\t\t//\r\n\t\t// STRUCTURE_CONTAINER: \"container\",\r\n\t\t// near source align to nearest storage\r\n\t\t//\r\n\t\t// STRUCTURE_LINK: \"link\",\r\n\t\t// near container at source\r\n\r\n\t\t// STRUCTURE_EXTRACTOR: \"extractor\",\r\n\t\t// STRUCTURE_ROAD: \"road\",\r\n\t\t// STRUCTURE_WALL: \"constructedWall\",\r\n\t\t// STRUCTURE_RAMPART: \"rampart\",\r\n\t\t//\r\n\t\t// STRUCTURE_PORTAL: \"portal\",\r\n\t\t// STRUCTURE_KEEPER_LAIR: \"keeperLair\",\r\n\t\t// STRUCTURE_CONTROLLER: \"controller\",\r\n\t\t// STRUCTURE_OBSERVER: \"observer\",\r\n\t\t// STRUCTURE_POWER_BANK: \"powerBank\",\r\n\t\t// STRUCTURE_INVADER_CORE: \"invaderCore\",\r\n\t};\r\n\r\n\tthis.assessPosForStructure = (x, y) => {\r\n\t\t//console.log(`x: ${JSON.stringify(x)}, y:${JSON.stringify(y)}`);\r\n\t\tconst canBePlaced = this.canStructureBePlaced(x, y);\r\n\t\t//console.log(`canBePlaced: ${JSON.stringify(canBePlaced)}`);\r\n\t\treturn canBePlaced;\r\n\t};\r\n\r\n\tthis.canStructureBePlaced = (x, y) => {\r\n\t\tlet surroundingPositions = this.getSurroundingPositions(x, y),\r\n\t\t\tcanBePlaced = true,\r\n\t\t\tid = this.helper.getPosName(x, y),\r\n\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t//console.log(`positionData = ${JSON.stringify(positionData)}`);\r\n\r\n\t\tif (positionData) {\r\n\t\t\t// check each surrounding pos to see if you  can build on it\r\n\t\t\t// need to think of a better way of doing this. Checking surrounding positions to see where the current position is.\r\n\r\n\t\t\tfor (const i in surroundingPositions) {\r\n\t\t\t\tconst pos = surroundingPositions[i];\r\n\t\t\t\tif (!this.doesPositionHaveOtherAccess(pos.x, pos.y)) {\r\n\t\t\t\t\tcanBePlaced = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// surroundingPositions.every((pos) => {\r\n\t\t\t// \tif (this.doesPositionHaveOtherAccess(pos.x, pos.y)) {\r\n\t\t\t// \t\tcanBePlaced = true;\r\n\t\t\t// \t\treturn true;\r\n\t\t\t// \t}\r\n\t\t\t// });\r\n\r\n\t\t\tif (canBePlaced) {\r\n\t\t\t\t// current pos is the top right\r\n\t\t\t\tlet strucType = this.structureArray.shift();\r\n\r\n\t\t\t\tif (!this.roomSurveyData.structureMap[strucType]) {\r\n\t\t\t\t\tthis.roomSurveyData.structureMap[strucType] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.roomSurveyData.structureMap[strucType].push({ x, y });\r\n\t\t\t\t//console.log(`positionData = ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\t\t\t\t//console.log(`structureMap = ${JSON.stringify(this.roomSurveyData.structureMap)}`);\r\n\t\t\t\tpositionData.hasStructure = true;\r\n\t\t\t\tthis.roomSurveyData.positionData[id] = positionData;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcanBePlaced = false;\r\n\t\t}\r\n\r\n\t\treturn canBePlaced;\r\n\t};\r\n\r\n\tthis.doesPositionHaveOtherAccess = (x, y) => {\r\n\t\tlet surroundingPositions = this.getSurroundingPositions(x, y),\r\n\t\t\thasOtherAccess = false;\r\n\r\n\t\t//console.log(`surroundingPositions: ${JSON.stringify(surroundingPositions)}`);\r\n\r\n\t\tfor (const i in surroundingPositions) {\r\n\t\t\tlet pos = surroundingPositions[i];\r\n\t\t\tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t\t// position that you can travel over , doens't have\r\n\t\t\tif (positionData && positionData.canTravel && !positionData.hasStructure) {\r\n\t\t\t\thasOtherAccess = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// surroundingPositions.every((pos) => {\r\n\t\t// \tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t// \t\tpositionData = this.roomSurveyData.positionData[id];\r\n\r\n\t\t// \t// position that you can travel over , doens't have\r\n\t\t// \tif (positionData && positionData.canTravel && !positionData.hasStructure && pos.x != originX && pos.y != originY) {\r\n\t\t// \t\thasOtherAccess = true;\r\n\t\t// \t\treturn false;\r\n\t\t// \t}\r\n\t\t// });\r\n\r\n\t\treturn hasOtherAccess;\r\n\t};\r\n\r\n\tthis.getSurroundingPositions = (x, y) => {\r\n\t\tlet topPos = { x: x, y: y + 1 },\r\n\t\t\ttopRightPos = { x: x + 1, y: y + 1 },\r\n\t\t\ttopLeftPos = { x: x - 1, y: y + 1 },\r\n\t\t\tleftPos = { x: x - 1, y },\r\n\t\t\trightPos = { x: x, y: y + 1 },\r\n\t\t\tbottomPos = { x: x, y: y - 1 },\r\n\t\t\tbottomLeftPos = { x: x - 1, y: y - 1 },\r\n\t\t\tbottomRightPos = { x: x + 1, y: y - 1 };\r\n\r\n\t\t//const primaryPositions = [topPos, rightPos, bottomPos, leftPos];\r\n\t\t//const secondaryPositions = [topLeftPos, topRightPos, bottomLeftPos, bottomRightPos];\r\n\t\treturn [topPos, rightPos, bottomPos, leftPos, topLeftPos, topRightPos, bottomLeftPos, bottomRightPos];\r\n\t};\r\n\r\n\tthis.createNewStructureMap = function () {\r\n\t\treturn {\r\n\t\t\tspawn: {},\r\n\t\t\textension: {},\r\n\t\t\troad: {},\r\n\t\t\tconstructedWall: {},\r\n\t\t\trampart: {},\r\n\t\t\tcontroller: {},\r\n\t\t\tlink: {},\r\n\t\t\tstorage: {},\r\n\t\t\ttower: {},\r\n\t\t\tobserver: {},\r\n\t\t\tpowerSpawn: {},\r\n\t\t\textractor: {},\r\n\t\t\tlab: {},\r\n\t\t\tterminal: {},\r\n\t\t\tcontainer: {},\r\n\t\t\tnuker: {},\r\n\t\t};\r\n\t};\r\n\r\n\tthis.getSurroundingPositionExitPathCounts = (x, y) => {\r\n\t\tthis.exitPositions = [\r\n\t\t\t{ x: x - 1, y: -1 },\r\n\t\t\t{ x: x, y: -1 },\r\n\t\t\t{ x: x + 1, y: -1 },\r\n\t\t\t{ x: x - 1, y },\r\n\t\t\t{ x: x + 1, y },\r\n\t\t\t{ x: x - 1, y: +1 },\r\n\t\t\t{ x: x, y: +1 },\r\n\t\t\t{ x: x + 1, y: +1 },\r\n\t\t];\r\n\r\n\t\tlet count = 0;\r\n\r\n\t\tthis.exitPositions.forEach((pos) => {\r\n\t\t\t//console.log(`pos: ${JSON.stringify(pos)}`);\r\n\t\t\tlet id = this.helper.getPosName(pos.x, pos.y),\r\n\t\t\t\tpositionData = this.roomSurveyData.positionData[id];\r\n\t\t\t//console.log(`id: ${JSON.stringify(id)}`);\r\n\t\t\t//console.log(`roomSurveyData.positionData: ${JSON.stringify(this.roomSurveyData.positionData)}`);\r\n\r\n\t\t\tif (positionData && positionData.canBuild) {\r\n\t\t\t\tcount += this.roomSurveyData.exitPathPosCounts[id];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn count;\r\n\t};\r\n\r\n\tthis.identifyRoads = function (room) {\r\n\t\t// find sources and path to controller\r\n\t};\r\n\r\n\tthis.structurePlacement = function (structure) {\r\n\t\t/* structure can only be placed if it's accessible\r\n        what is accessible patterns\r\n        how to define accessible?\r\n        minimal\r\n        - if two free spaces exist\r\n        basic collection\r\n        - three structures and there is enough free space for it still to be accessible\r\n\r\n        we need to track \r\n        - road (mandatory free space) placement \r\n        - structures\r\n        \r\n        How to determine structure placement and order?\r\n        - \r\n\r\n        coordinates\r\n        -------------\r\n        | 1 | 2 | 3 |\r\n        -------------\r\n        | 4 | o | 6 |\r\n        -------------\r\n        | 7 | 8 | 9 | \r\n\t\t-------------\r\n\t\t\r\n\t\t--------------------------\r\n        |  1 |  2 |  3 |  4 |  5 |\r\n        --------------------------\r\n        |  6 |  7 |  8 |  9 | 10 |\r\n        --------------------------\r\n        | 11 | 12 | 13 | 14 | 15 |\r\n\t\t--------------------------\r\n\t\t| 16 | 17 | 18 | 19 | 20 |\r\n\t\t--------------------------\r\n\t\t| 21 | 22 | 23 | 24 | 25 |\r\n\t\t--------------------------\r\n\t\t\r\n\t\t--------------------------\r\n        |  S |  S |  3 |  4 |  5 |\r\n        --------------------------\r\n        |  S |  7 |  8 |  9 | 10 |\r\n        --------------------------\r\n        | 11 | 12 | 13 | 14 | 15 |\r\n\t\t--------------------------\r\n\t\t| 16 | 17 | 18 | 19 | 20 |\r\n\t\t--------------------------\r\n\t\t| 21 | 22 | 23 | 24 | 25 |\r\n        --------------------------\r\n\r\n\r\n    */\r\n\t};\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/roomSurveyor.js?");

/***/ })

/******/ })));